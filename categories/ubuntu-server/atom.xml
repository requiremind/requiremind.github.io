<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ubuntu server | require 'mind']]></title>
  <link href="http://requiremind.com/categories/ubuntu-server/atom.xml" rel="self"/>
  <link href="http://requiremind.com/"/>
  <updated>2015-01-04T20:52:48+01:00</updated>
  <id>http://requiremind.com/</id>
  <author>
    <name><![CDATA[requireMind]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Deploying a Rails App on Your Own Server - The Ultimate Guide]]></title>
    <link href="http://requiremind.com/deploying-a-rails-app-on-your-own-server-the-ultimate-guide"/>
    <updated>2014-02-05T23:28:00+01:00</updated>
    <id>http://requiremind.com/deploying-a-rails-app-on-your-own-server-the-ultimate-guide</id>
    <content type="html"><![CDATA[<p>Recently I&rsquo;ve been giving life to a project of my own (<a href="https://6lock.com">6lock.com</a>) and I had to go through some steps to get the Rails app up and
running with the best possible conditions.</p>

<p>In this tutorial, I&rsquo;ll try to show you how to deploy your Rails app on a <em>secured</em> Ubuntu Server 12.04 using <em>Capistrano</em>, <em>Unicorn</em>, <em>Nginx</em>. Part of my
setup includes <em>MongoDB</em> and <em>Sidekiq</em> so I figured I would also explain how I configured those two.</p>

<!-- more -->


<p>Here I&rsquo;ll be assuming that you already have a basic understanding of Rails, git and rvm, and that you have a working application (running on your machine)
that also has a Github or Bitbucket repo (or any other code hosting service).</p>

<p>Here are the tutorials I used myself. Please note that this guide will be highly based on those other tutorials, my primary goal was to have all the needed
information in one unique place.</p>

<ul>
<li><a href="https://www.digitalocean.com/community/articles/initial-server-setup-with-ubuntu-12-04">Initial Server Setup with Ubuntu 12.04</a></li>
<li><a href="http://www.thefanclub.co.za/how-to/how-secure-ubuntu-1204-lts-server-part-1-basics">How to Secure Ubuntu 12.04 Server</a></li>
<li><a href="https://www.digitalocean.com/community/articles/how-to-add-swap-on-ubuntu-12-04">How to Add Swap on Ubuntu 12.04</a></li>
<li><a href="https://coderwall.com/p/yz8cha">Deploying Rails app using Nginx, Unicorn and Capistrano</a></li>
<li><a href="http://www.westphahl.net/blog/2012/01/03/setting-up-https-with-nginx-and-startssl/">Setting up HTTPS with Nginx and StartSSL</a></li>
</ul>


<p>First of all you need to have a private server on which you have a ssh access. If you do not have one yet, I suggest taking a VPS at
<a href="https://www.digitalocean.com/">Digital Ocean</a>, they have SSDs in every server and you can have one in just under one minute, starting from 5$/month.</p>

<p><em>A lot of the following commands need <code>sudo</code> to work.</em></p>

<p>You can start by updating packages with <code>apt-get update</code>.</p>

<p>Annnnnnddd that&rsquo;s a go!</p>

<h2>Setting up some basic security rules</h2>

<h3>Users management</h3>

<p>First, change the <strong>root password</strong>:</p>

<pre><code>passwd
</code></pre>

<p>Then you can add a new user so that after we can allow this new user to log in via <strong>ssh</strong> and <strong>disallow root login</strong>.</p>

<pre><code>adduser johnsnow
</code></pre>

<p>We now have to give some permissions to this new user. Edit the corresponding file with:</p>

<pre><code>visudo
</code></pre>

<p>And add this line:</p>

<pre><code>johnsnow ALL=(ALL:ALL) ALL
</code></pre>

<h3>SSH hardening</h3>

<p>Edit the related configuration file. I always use <code>nano</code> but you can use <code>vi</code> or any other editor of your choice.</p>

<pre><code>nano /etc/ssh/sshd_config
</code></pre>

<p>Add or change these lines:</p>

<pre><code>Port xxxxx
Protocol 2
PermitRootLogin no
UseDNS no
AllowUsers johnsnow
DebianBanner no
</code></pre>

<p><code>Port</code>: you can choose any unused port from 1025 up to 65536, this is the port you&rsquo;ll use to log in via ssh, instead of the standard port 22.
This makes it harder for someone to try to log in on your server.</p>

<p><code>Protocol 2</code>: tells ssh to use SSHv2 instead of SSHv1, see <a href="http://www.snailbook.com/faq/ssh-1-vs-2.auto.html">SSHv1 vs SSHv2</a> for a list of the differences.</p>

<p><code>PermitRootLogin no</code>: disables the login via ssh using <strong>root</strong>.</p>

<p><code>UseDNS no</code>: this option is probably the least important one, check it out here
<a href="http://unix.stackexchange.com/questions/56941/what-is-the-point-of-sshd-usedns-option">What is the Point of sshd UseDNS Option</a>.</p>

<p><code>AllowUsers johnsnow</code>: makes <strong>johnsnow</strong> the only user allowed to log in via ssh.</p>

<p><code>DebianBanner no</code>: prevents ssh from broadcasting the distribution information, more information here
<a href="https://scottlinux.com/2011/06/14/disable-debian-banner-suffix-on-ssh-server/">Disable Debian Banner Suffix on ssh Server</a>.</p>

<p>Then you just have to <code>reload</code> ssh:</p>

<pre><code>reload ssh
</code></pre>

<p>That&rsquo;s it, you&rsquo;re done, you can no longer log in using <strong>root</strong>. Now, you can do it using your user like so:</p>

<pre><code>ssh johnsnow@your_server_ip_address -p xxxxx
</code></pre>

<p><code>xxxxx</code> being the port you chose earlier in the configuration.</p>

<h3>Firewall setup</h3>

<p>Next we are going to set up a firewall that&rsquo;s called UFW as in <strong>Uncomplicated Firewall</strong>.</p>

<pre><code>apt-get install ufw
</code></pre>

<p>And we are going to allow the port we use for <strong>ssh</strong>, <strong>http</strong> and <strong>https</strong> protocols.</p>

<pre><code>ufw allow xxxxx
ufw allow http
ufw allow https
</code></pre>

<p><code>xxxxx</code> still being our ssh port.</p>

<p>Now we just have to enable the firewall with:</p>

<pre><code>ufw allow enable
</code></pre>

<p>Now open a second shell and try logging in again via ssh to be sure you didn&rsquo;t break anything with the firewall rules.</p>

<p>You can check everything with:</p>

<pre><code>ufw status verbose
</code></pre>

<h3>Shared memory</h3>

<p>To quote the tutorial I followed: <em>&ldquo;shared memory can be used in an attack against a running service&rdquo;</em>. To secure it, just edit the <strong>fstab</strong> file.</p>

<pre><code>nano /etc/fstab
</code></pre>

<p>And add this line:</p>

<pre><code>tmpfs     /dev/shm     tmpfs     defaults,noexec,nosuid     0     0
</code></pre>

<p>This works on Ubuntu 12.04, for later versions, replace <code>/dev/shm</code> by <code>/run/shm</code>. Just save and reboot.</p>

<h3>Network security</h3>

<p>Edit the <strong>sysctl</strong> file:</p>

<pre><code>nano /etc/sysctl.conf
</code></pre>

<p>And add or change the following lines:</p>

<pre><code># IP Spoofing protection
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1

# Ignore ICMP broadcast requests
net.ipv4.icmp_echo_ignore_broadcasts = 1

# Disable source packet routing
net.ipv4.conf.all.accept_source_route = 0
net.ipv6.conf.all.accept_source_route = 0 
net.ipv4.conf.default.accept_source_route = 0
net.ipv6.conf.default.accept_source_route = 0

# Ignore send redirects
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0

# Block SYN attacks
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_syn_backlog = 2048
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_syn_retries = 5

# Log Martians
net.ipv4.conf.all.log_martians = 1
net.ipv4.icmp_ignore_bogus_error_responses = 1

# Ignore ICMP redirects
net.ipv4.conf.all.accept_redirects = 0
net.ipv6.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0 
net.ipv6.conf.default.accept_redirects = 0

# Ignore Directed pings
net.ipv4.icmp_echo_ignore_all = 1
</code></pre>

<p>To reload the configuration, just issue:</p>

<pre><code>sysctl -p
</code></pre>

<h3>IP Spoofing</h3>

<p>To prevent this, edit the <strong>host</strong> file:</p>

<pre><code>nano /etc/host.conf
</code></pre>

<p>And add these lines:</p>

<pre><code>order bind,hosts
nospoof on
</code></pre>

<h3>DenyHosts</h3>

<p>To quote the tutorial I followed once again: <em>&ldquo;denyHosts is a python program that automatically blocks SSH attacks by adding entries to /etc/hosts.deny.
DenyHosts will also inform Linux administrators about offending hosts, attacked users and suspicious logins&rdquo;</em>.</p>

<p>Install the program:</p>

<pre><code>apt-get install denyhosts
</code></pre>

<p>If you have to edit email settings or other options, you can edit the following file:</p>

<pre><code>nano /etc/denyhosts.conf
</code></pre>

<h3>Fail2Ban</h3>

<p>Fail2Ban listens for failed attemps of connections, exploits etc.. and blocks corresponding IP addresses by updating the firewall rules dynamically.<br/>
To install it, just use the usual:</p>

<pre><code>apt-get install fail2ban
</code></pre>

<p>Edit the configuration file and change the ssh port to the one you are using in the &ldquo;ssh&rdquo; section of the file.</p>

<pre><code>nano /etc/fail2ban/jail.conf
</code></pre>

<p>Change <code>port = ssh</code> to <code>port = xxxxx</code>.</p>

<p>And finally, restart Fail2Ban with:</p>

<pre><code>service fail2ban restart
</code></pre>

<h3>Rootkits</h3>

<p>To finish with security we are going to install programs that check the server for rootkits. A rootkit is a software that has been built to hide processes or
programs and grant them privileged access.</p>

<p>Install two programs:</p>

<pre><code>apt-get install rkhunter chkrootkit
</code></pre>

<p>Update and run the first one:</p>

<pre><code>rkhunter --update
rkhunter --propupd
rkhunter --check
</code></pre>

<p>Just run the second one:</p>

<pre><code>chkrootkit
</code></pre>

<h3>AppArmor</h3>

<p>I&rsquo;ll let Wikipedia describe what it does: <a href="http://en.wikipedia.org/wiki/AppArmor">http://en.wikipedia.org/wiki/AppArmor</a>.</p>

<pre><code>apt-get install apparmor apparmor-profiles
</code></pre>

<h2>SWAP</h2>

<p>If you have a limited RAM, say 512M, you might want to add some swap just in case.<br/>
First check that you do not have swap already in use:</p>

<pre><code>swapon -s
</code></pre>

<p>If this results in an empty list, then you&rsquo;re good.<br/>
You can now create the swapfile and setup a swap area with it:</p>

<pre><code>dd if=/dev/zero of=/swapfile bs=1024 count=512k
mkswap /swapfile
</code></pre>

<p>Now you can enable the file:</p>

<pre><code>swapon /swapfile
</code></pre>

<p>Run the first command to see what changed:</p>

<pre><code>swapon -s
</code></pre>

<p>You should see a new line in the list.<br/>
Now we have to edit <strong>/etc/fstab</strong> file so that these changes still work after a reboot:</p>

<pre><code>nano /etc/fstab
</code></pre>

<p>And add this line:</p>

<pre><code>/swapfile       none    swap    sw      0       0
</code></pre>

<p>Now we have to choose when the system should use this swap space instead of using RAM. For this we have to choose a value between 0 and 100 that&rsquo;s going to be the
left percentage of RAM before using swap. For instance, if we have 512M RAM and we set the value to 10, it means the system will start using swap when we have
less than 10% of RAM available, or if you prefere less than 50M available. Here we set the value to <strong>0</strong>, this means the system will swap only in case of emergency
at the last moment. I personnaly had to set it to <strong>20</strong> for the assets precompilation to work, otherwise I was running into an error (the only indication was
&ldquo;<em>killed</em>&rdquo;).</p>

<pre><code>echo 0 | sudo tee /proc/sys/vm/swappiness
echo vm.swappiness = 0 | sudo tee -a /etc/sysctl.conf
</code></pre>

<p>Just set permissions on the file and you&rsquo;re done:</p>

<pre><code>sudo chown root:root /swapfile 
sudo chmod 0600 /swapfile
</code></pre>

<h2>Nginx and Unicorn</h2>

<h3>RVM, MongoDB, Redis and other stuff</h3>

<p>Before actually installing and configuring Nginx and Unicorn, we&rsquo;re going to install <strong>rvm</strong>, <strong>git</strong>, and <strong>nodejs</strong>.<br/>
First, let&rsquo;s install <strong>curl</strong>:</p>

<pre><code>apt-get install curl
</code></pre>

<p>And <strong>rvm</strong>:</p>

<pre><code>curl -L get.rvm.io | bash -s stable
</code></pre>

<p>Then make it available in your current shell:</p>

<pre><code>source ~/.rvm/scripts/rvm
</code></pre>

<p>And install the requirements:</p>

<pre><code>rvm requirements
</code></pre>

<p>Install the ruby version your are using in your application, for instance 2.0.0, and make it the default for the system:</p>

<pre><code>rvm install 2.0.0
rvm use 2.0.0 --default
</code></pre>

<p>Update <strong>rubygems</strong> just in case:</p>

<pre><code>rvm rubygems current
</code></pre>

<p>Install git:</p>

<pre><code>apt-get install git-core
</code></pre>

<p>I usually install <strong>NodeJS</strong> for assets precompilation:</p>

<pre><code>apt-get install nodejs
</code></pre>

<p>Let&rsquo;s install <strong>MongoDB</strong>:</p>

<pre><code>apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10
echo 'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen' | sudo tee /etc/apt/sources.list.d/mongodb.list
apt-get update
apt-get install mongodb-10gen
</code></pre>

<p>We have to create the default <strong>/data/db</strong> directory and set the owner and permissions accordingly:</p>

<pre><code>mkdir -p /data/db
chmod 0755 /data/db
chown mongodb /data/db
</code></pre>

<p>Let&rsquo;s install <strong>Redis</strong> now (for sidekiq):</p>

<pre><code>apt-get install redis-server
</code></pre>

<p>And we&rsquo;re going to need <strong>bundler</strong> too:</p>

<pre><code>gem install bundler
</code></pre>

<p>Finally, at some point, chances are that you&rsquo;re going to install some gem requiring <strong>Nokogiri</strong> which requires additional packages, so let&rsquo;s install those
packages beforehand:</p>

<pre><code>apt-get install libxslt-dev libxml2-dev
</code></pre>

<h3>Nginx</h3>

<p>It&rsquo;s now time to install <strong>Nginx</strong> and run it:</p>

<pre><code>apt-get install nginx
service nginx start
</code></pre>

<p>Now if you navigate to your_server_ip_address in a browser, you should see the default Nginx page.</p>

<p>Let&rsquo;s configure it. Add this in <strong>/etc/nginx/nginx.conf</strong>, in the <strong>http { &hellip; }</strong> block:</p>

<pre><code>upstream unicorn {
  server unix:/tmp/unicorn.your_project.sock fail_timeout=0;
}

server {
  listen 80 default_server deferred;
  # server_name example.com;
  root /home/johnsnow/apps/your_project/current/public;

  location ^~ /assets/ {
    gzip_static on;
    expires max;
    add_header Cache-Control public;
  }

  try_files $uri/index.html $uri @unicorn;
  location @unicorn {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://unicorn;
  }

  error_page 500 502 503 504 /500.html;
  client_max_body_size 20M;
  keepalive_timeout 10;
}
</code></pre>

<p>Let&rsquo;s break it down:</p>

<p>The <code>upstream</code> block will be used to proxy requests to a Unicorn unix socket (a socket used by Unicorn to listen and process requests). Right now there is no
socket yet but we&rsquo;ll be configuring this later on. Then we use this in the <code>server</code> block with the line <code>proxy_pass http://unicorn</code>.</p>

<p>The <code>root</code> line is used to point to the <strong>public</strong> directory of the Rails app. This path structure is the one set up by <strong>Capistrano</strong> when deploying the
application.</p>

<p>The <code>client_max_body_size</code> directive is used to set the maximum body size of client requests. Check it out here:
<a href="http://wiki.nginx.org/HttpCoreModule#client_max_body_size">http://wiki.nginx.org/HttpCoreModule#client_max_body_size</a>.</p>

<p>You can look the internet up for the rest of these options, you&rsquo;ll find way more information than what I could write here.</p>

<h3>Unicorn</h3>

<p>Add the <strong>unicorn</strong> gem to your project: in the Gemfile, add</p>

<p>``` ruby Gemfile</p>

<h1>I am currently using version 4.8.0</h1>

<p>gem &lsquo;unicorn&rsquo;, &lsquo;~> 4.8.0&rsquo;
```</p>

<p>We&rsquo;re going to create the configuration file for <strong>Unicorn</strong>: in your application, create a file <strong>config/unicorn.rb</strong>:</p>

<p>``` ruby config/unicorn.rb
root = &ldquo;/home/johnsnow/apps/your_project/current&rdquo;
working_directory root
pid &ldquo;#{root}/tmp/pids/unicorn.pid&rdquo;
stderr_path &ldquo;#{root}/log/unicorn.log&rdquo;
stdout_path &ldquo;#{root}/log/unicorn.log&rdquo;</p>

<p>listen &ldquo;/tmp/unicorn.your_project.sock&rdquo;
worker_processes 2
timeout 30</p>

<h1>Force the bundler gemfile environment variable to</h1>

<h1>reference the capistrano &ldquo;current&rdquo; symlink</h1>

<p>before_exec do |_|
  ENV[&ldquo;BUNDLE_GEMFILE&rdquo;] = File.join(root, &lsquo;Gemfile&rsquo;)
end
```</p>

<p>And an initialization script for <strong>Unicorn</strong> as well in <strong>config/unicorn_init.sh</strong>, this file will be symlinked later in <strong>/etc/init.d/</strong>:</p>

<p>``` bash config/unicorn_init.sh</p>

<h1>!/bin/sh</h1>

<h3>BEGIN INIT INFO</h3>

<h1>Provides:          unicorn</h1>

<h1>Required-Start:    $remote_fs $syslog</h1>

<h1>Required-Stop:     $remote_fs $syslog</h1>

<h1>Default-Start:     2 3 4 5</h1>

<h1>Default-Stop:      0 1 6</h1>

<h1>Short-Description: Manage unicorn server</h1>

<h1>Description:       Start, stop, restart unicorn server for a specific application.</h1>

<h3>END INIT INFO</h3>

<p>set -e</p>

<h1>Feel free to change any of the following variables for your app:</h1>

<p>TIMEOUT=${TIMEOUT-60}
APP_ROOT=/home/johnsnow/apps/your_project/current
PID=$APP_ROOT/tmp/pids/unicorn.pid
CMD=&ldquo;cd $APP_ROOT; bundle exec unicorn -D -c $APP_ROOT/config/unicorn.rb -E production&rdquo;
AS_USER=johnsnow
set -u</p>

<p>OLD_PIN=&ldquo;$PID.oldbin&rdquo;</p>

<p>sig () {
  test -s &ldquo;$PID&rdquo; &amp;&amp; kill &ndash;$1 <code>cat $PID</code>
}</p>

<p>oldsig () {
  test -s $OLD_PIN &amp;&amp; kill &ndash;$1 <code>cat $OLD_PIN</code>
}</p>

<p>run () {
  if [ &ldquo;$(id -un)&rdquo; = &ldquo;$AS_USER&rdquo; ]; then</p>

<pre><code>eval $1
</code></pre>

<p>  else</p>

<pre><code>su -c "$1" - $AS_USER
</code></pre>

<p>  fi
}</p>

<p>case &ldquo;$1&rdquo; in
start)
  sig 0 &amp;&amp; echo >&amp;2 &ldquo;Already running&rdquo; &amp;&amp; exit 0
  run &ldquo;$CMD&rdquo;
  ;;
stop)
  sig QUIT &amp;&amp; exit 0
  echo >&amp;2 &ldquo;Not running&rdquo;
  ;;
force-stop)
  sig TERM &amp;&amp; exit 0
  echo >&amp;2 &ldquo;Not running&rdquo;
  ;;
restart|reload)
  sig HUP &amp;&amp; echo reloaded OK &amp;&amp; exit 0
  echo >&amp;2 &ldquo;Couldn&rsquo;t reload, starting &lsquo;$CMD&rsquo; instead&rdquo;
  run &ldquo;$CMD&rdquo;
  ;;
upgrade)
  if sig USR2 &amp;&amp; sleep 2 &amp;&amp; sig 0 &amp;&amp; oldsig QUIT
  then</p>

<pre><code>n=$TIMEOUT
while test -s $OLD_PIN &amp;&amp; test $n -ge 0
do
  printf '.' &amp;&amp; sleep 1 &amp;&amp; n=$(( $n - 1 ))
done
echo

if test $n -lt 0 &amp;&amp; test -s $OLD_PIN
then
  echo &gt;&amp;2 "$OLD_PIN still exists after $TIMEOUT seconds"
  exit 1
fi
exit 0
</code></pre>

<p>  fi
  echo >&amp;2 &ldquo;Couldn&rsquo;t upgrade, starting &lsquo;$CMD&rsquo; instead&rdquo;
  run &ldquo;$CMD&rdquo;
  ;;
reopen-logs)
  sig USR1
  ;;
*)
  echo >&amp;2 &ldquo;Usage: $0 &lt;start|stop|restart|upgrade|force-stop|reopen-logs>&rdquo;
  exit 1
  ;;
esac
```</p>

<p>The file is pretty much straightforward so I suggest you read it and see what it does. Basically, it is used to manage the unicorn process.</p>

<h3>Capistrano</h3>

<p>Add the required gems to your Gemfile:</p>

<p><code>ruby Gemfile
gem 'capistrano', '~&gt; 2.15.4'
gem 'rvm-capistrano', '~&gt; 1.5.1'
</code></p>

<p>Now we create two files for Capistrano: <strong>Capfile</strong> and <strong>config/deploy.rb</strong> with the following command ran from the root directory of your app:</p>

<pre><code>capify .
</code></pre>

<p>As a side note, before we go further, I&rsquo;m supposing that you already have the mongoid gem or whatever ORM you&rsquo;re using and the sidekiq gem if you are using
sidekiq as well.</p>

<p>Let&rsquo;s write some instructions in the <strong>config/deploy.rb</strong> file:</p>

<p>``` ruby config/deploy.rb
require &ldquo;bundler/capistrano&rdquo;
require &ldquo;rvm/capistrano&rdquo;
require &lsquo;sidekiq/capistrano&rsquo;</p>

<p>server &ldquo;your_server_ip_address&rdquo;, :web, :app, :db, primary: true</p>

<p>set :application, &ldquo;your_project&rdquo;
set :user, &ldquo;johnsnow&rdquo;
set :port, xxxxx #your ssh port
set :deploy_to, &ldquo;/home/#{user}/apps/#{application}&rdquo;
set :deploy_via, :remote_cache
set :use_sudo, false</p>

<p>set :scm, &ldquo;git&rdquo;
set :repository, &ldquo;your_project.git&rdquo; #your application repo (for instance git@github.com:user/application.git)
set :branch, &ldquo;master&rdquo;</p>

<p>default_run_options[:pty] = true
ssh_options[:forward_agent] = true</p>

<p>after &ldquo;deploy&rdquo;, &ldquo;deploy:cleanup&rdquo; # keep only the last 5 releases</p>

<p>namespace :deploy do
  %w[start stop restart].each do |command|</p>

<pre><code>desc "#{command} unicorn server"
task command, roles: :app, except: { no_release: true } do
  run "/etc/init.d/unicorn_#{application} #{command}"
end
</code></pre>

<p>  end</p>

<p>  task :setup_config, roles: :app do</p>

<pre><code># symlink the unicorn init file in /etc/init.d/
sudo "ln -nfs #{current_path}/config/unicorn_init.sh /etc/init.d/unicorn_#{application}"
# create a shared directory to keep files that are not in git and that are used for the application
run "mkdir -p #{shared_path}/config"
# if you're using mongoid, create a mongoid.template.yml file and fill it with your production configuration
# and add your mongoid.yml file to .gitignore
put File.read("config/mongoid.template.yml"), "#{shared_path}/config/mongoid.yml"
puts "Now edit the config files in #{shared_path}."
</code></pre>

<p>  end
  after &ldquo;deploy:setup&rdquo;, &ldquo;deploy:setup_config&rdquo;</p>

<p>  task :symlink_config, roles: :app do</p>

<pre><code># symlink the shared mongoid config file in the current release
run "ln -nfs #{shared_path}/config/mongoid.yml #{release_path}/config/mongoid.yml"
</code></pre>

<p>  end
  after &ldquo;deploy:finalize_update&rdquo;, &ldquo;deploy:symlink_config&rdquo;</p>

<p>  desc &ldquo;Create MongoDB indexes&rdquo;
  task :mongoid_indexes do</p>

<pre><code>run "cd #{current_path} &amp;&amp; RAILS_ENV=production bundle exec rake db:mongoid:create_indexes", once: true
</code></pre>

<p>  end
  after &ldquo;deploy:update&rdquo;, &ldquo;deploy:mongoid_indexes&rdquo;</p>

<p>  desc &ldquo;Make sure local git is in sync with remote.&rdquo;
  task :check_revision, roles: :web do</p>

<pre><code>unless `git rev-parse HEAD` == `git rev-parse origin/master`
  puts "WARNING: HEAD is not the same as origin/master"
  puts "Run `git push` to sync changes."
  exit
end
</code></pre>

<p>  end
  before &ldquo;deploy&rdquo;, &ldquo;deploy:check_revision&rdquo;
end
```</p>

<p>I&rsquo;ve added some comments but feel free to read the rest of the file, it is straightforward as well.</p>

<p>Your <strong>Capfile</strong> should look like this:</p>

<p><code>ruby Capfile
load 'deploy'
load 'deploy/assets'
load 'config/deploy'
</code></p>

<p>Add your ssh key to the authorized keys on your server:</p>

<pre><code># replace the port, the user and your ip address accordingly
cat ~/.ssh/id_rsa.pub | ssh -p xxxxx johnsnow@your_server_ip_address 'mkdir -p ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys'
</code></pre>

<p>Make sure you pushed all your changes to your repository (on Github or Bitbucket for instance).</p>

<p>Now we have to tell capistrano to create the initial directory structure on the server as described in the recipe we just created:</p>

<pre><code>cap deploy:setup
</code></pre>

<p>You can now go to your server and edit the <strong>mongoid.yml</strong> file in <strong>/home/johnsnow/apps/your_project/shared/config/mongoid.yml</strong>.</p>

<p>Then you&rsquo;ll have to run:</p>

<pre><code>cap deploy:cold
</code></pre>

<p>From the documentation, this will deploy the code, run any pending migrations (not used here because it&rsquo;s MongoDB), and then instead of invoking
<code>deploy:restart</code>, it will invoke <code>deploy:start</code> to fire up the application servers. Check it out here
<a href="http://capitate.rubyforge.org/recipes/deploy.html">http://capitate.rubyforge.org/recipes/deploy.html</a>.</p>

<p>Delete the default Nginx server block:</p>

<pre><code>rm /etc/nginx/sites-enabled/default
</code></pre>

<p>You can restart the <strong>nginx</strong> service to make sure the changes are taken into account:</p>

<pre><code>service nginx restart
</code></pre>

<p>Make sure <strong>Unicorn</strong> is restarted when rebooting the server:</p>

<pre><code>update-rc.d -f unicorn_your_project defaults
</code></pre>

<p>Push your changes (locally) one last time and deploy:</p>

<pre><code>git push
cap deploy
</code></pre>

<p>That&rsquo;s it, your app should be up and running when typing your server&rsquo;s ip address in your browser!</p>

<h2>Sidekiq</h2>

<p>We already required sidekiq in the capistrano recipe so everything should be fine but what if we restart the server? Let&rsquo;s create a script to make sure all the
processes properly restart when rebooting. This script is made to work with <strong>Upstart</strong>.</p>

<p>Create a file <strong>/etc/init/sidekiq.conf</strong>:</p>

<p>``` bash /etc/init/sidekiq.conf</p>

<h1>/etc/init/sidekiq.conf &ndash; Sidekiq config</h1>

<h1>This example config should work with Ubuntu 12.04+.  It</h1>

<h1>allows you to manage multiple Sidekiq instances with</h1>

<h1>Upstart, Ubuntu&rsquo;s native service management tool.</h1>

<p>#</p>

<h1>Save this config as /etc/init/sidekiq.conf then manage sidekiq with:</h1>

<h1>sudo start sidekiq index=0</h1>

<h1>sudo stop sidekiq index=0</h1>

<h1>sudo status sidekiq index=0</h1>

<p>#</p>

<h1>or use the service command:</h1>

<h1>sudo service sidekiq {start,stop,restart,status}</h1>

<p>#</p>

<p>description &ldquo;Sidekiq Background Worker&rdquo;</p>

<h1>no &ldquo;start on&rdquo;, we don&rsquo;t want to automatically start</h1>

<p>stop on (stopping workers or runlevel [06])</p>

<h1>change to match your deployment user</h1>

<p>setuid johnsnow
setgid johnsnow</p>

<p>respawn
respawn limit 3 30</p>

<h1>TERM and USR1 are sent by sidekiqctl when stopping sidekiq.  Without declaring these as normal exit codes, it just respawns.</h1>

<p>normal exit 0 TERM USR1</p>

<h1>instance $index</h1>

<p>script</p>

<h1>this script runs in /bin/sh by default</h1>

<h1>respawn as bash so we can source in rbenv</h1>

<p>exec /bin/bash &lt;<EOT
  # use syslog for logging
  # exec &> /dev/kmsg</p>

<p>  # pull in system rbenv
  # export HOME=/home/deploy
  # source /etc/profile.d/rbenv.sh</p>

<p>  cd /home/johnsnow/apps/your_project/current
  nohup bundle exec sidekiq -e production -C config/sidekiq.yml -i 0 -P tmp/pids/sidekiq.pid >> log/sidekiq.log 2>&amp;1 &amp;
EOT
end script
```</p>

<p>Here are the options for the line starting with <code>nohup</code>:<br/>
<code>-e</code>: the environment<br/>
<code>-C</code>: a config file eventhough we do not have one<br/>
<code>-i</code>: sidekiq process index, from 0 to whatever you want, you&rsquo;ll have to loop and increment the value if you want to create multiple processes<br/>
<code>-P</code>: the file holding sidekiq&rsquo;s process id</p>

<p><code>nohup</code> is used to run sidekiq in the background and therefore keeping it alive event after logging off.</p>

<p>I took the line from this file, check it out:
<a href="https://github.com/mperham/sidekiq/blob/master/lib/sidekiq/capistrano2.rb">https://github.com/mperham/sidekiq/blob/master/lib/sidekiq/capistrano2.rb</a>.</p>

<h2>Setup daily MongoDB backups</h2>

<p>You&rsquo;ll often want to setup backups so here we go: just create a directory to store these backups.</p>

<pre><code>mkdir /home/johnsnow/dumps
</code></pre>

<p>Then create a script to actually make a dump:</p>

<p>``` bash /home/johnsnow/mongodump</p>

<h1>!/bin/bash</h1>

<p>DUMPPATH=/home/johnsnow/dumps # dumps directory we just created
MONGODBNAME=your_project_production # your MongoDB database name
DAY=<code>/bin/date +%Y%m%d</code> # today&rsquo;s datetime</p>

<p>mongodump &mdash;db $MONGODBNAME &mdash;out $DUMPPATH/mongo<em>$DAY # run the command we those variables set
cd $DUMPPATH/mongo</em>$DAY # navigate to the folder where the dump was saved
tar -cvzf &ldquo;$DUMPPATH/mongo_$DAY.tar&rdquo; $MONGODBNAME # create an archive out of that dump</p>

<p>cd $DUMPPATH
rm -rf $DUMPPATH/mongo_$DAY # remove the dump because we only keep the archive version
```</p>

<p>Next make it executable:</p>

<pre><code>chmod +x mongodump
</code></pre>

<p>And create a cronjob:</p>

<pre><code>sudo crontab -e

# add the next line in the file
@daily /home/raindal/mongodump
</code></pre>

<p><code>@daily</code> means the script will be executed everyday at midnight.</p>

<p>That&rsquo;s it for backups!</p>

<h2>The end</h2>

<p>I hope it helps! If I forgot something, be sure to leave a comment below and I&rsquo;ll try to answer as quickly as I can.</p>

<p>Just in case you run in the same problems I did, I had to run another <code>update-rc.d -f unicorn_your_project defaults</code> at the end in order to have unicorn restarting
on server reboot. The second error was hapenning when I was deploying the application with <code>cap deploy</code> and the only indication was &ldquo;<em>killed</em>&rdquo; just in the
middle of the assets precompilation. To fix this I just had to set up some swap space because I was lacking memory.</p>
]]></content>
  </entry>
  
</feed>
