<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby on rails | require 'mind']]></title>
  <link href="http://requiremind.com/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://requiremind.com/"/>
  <updated>2015-01-04T17:22:52+01:00</updated>
  <id>http://requiremind.com/</id>
  <author>
    <name><![CDATA[requireMind]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Deploying a Rails App on Your Own Server - The Ultimate Guide]]></title>
    <link href="http://requiremind.com/deploying-a-rails-app-on-your-own-server-the-ultimate-guide"/>
    <updated>2014-02-05T23:28:00+01:00</updated>
    <id>http://requiremind.com/deploying-a-rails-app-on-your-own-server-the-ultimate-guide</id>
    <content type="html"><![CDATA[<p>Recently I&rsquo;ve been giving life to a project of my own (<a href="https://6lock.com">6lock.com</a>) and I had to go through some steps to get the Rails app up and
running with the best possible conditions.</p>

<p>In this tutorial, I&rsquo;ll try to show you how to deploy your Rails app on a <em>secured</em> Ubuntu Server 12.04 using <em>Capistrano</em>, <em>Unicorn</em>, <em>Nginx</em>. Part of my
setup includes <em>MongoDB</em> and <em>Sidekiq</em> so I figured I would also explain how I configured those two.</p>

<!-- more -->


<p>Here I&rsquo;ll be assuming that you already have a basic understanding of Rails, git and rvm, and that you have a working application (running on your machine)
that also has a Github or Bitbucket repo (or any other code hosting service).</p>

<p>Here are the tutorials I used myself. Please note that this guide will be highly based on those other tutorials, my primary goal was to have all the needed
information in one unique place.</p>

<ul>
<li><a href="https://www.digitalocean.com/community/articles/initial-server-setup-with-ubuntu-12-04">Initial Server Setup with Ubuntu 12.04</a></li>
<li><a href="http://www.thefanclub.co.za/how-to/how-secure-ubuntu-1204-lts-server-part-1-basics">How to Secure Ubuntu 12.04 Server</a></li>
<li><a href="https://www.digitalocean.com/community/articles/how-to-add-swap-on-ubuntu-12-04">How to Add Swap on Ubuntu 12.04</a></li>
<li><a href="https://coderwall.com/p/yz8cha">Deploying Rails app using Nginx, Unicorn and Capistrano</a></li>
<li><a href="http://www.westphahl.net/blog/2012/01/03/setting-up-https-with-nginx-and-startssl/">Setting up HTTPS with Nginx and StartSSL</a></li>
</ul>


<p>First of all you need to have a private server on which you have a ssh access. If you do not have one yet, I suggest taking a VPS at
<a href="https://www.digitalocean.com/">Digital Ocean</a>, they have SSDs in every server and you can have one in just under one minute, starting from 5$/month.</p>

<p><em>A lot of the following commands need <code>sudo</code> to work.</em></p>

<p>You can start by updating packages with <code>apt-get update</code>.</p>

<p>Annnnnnddd that&rsquo;s a go!</p>

<h2>Setting up some basic security rules</h2>

<h3>Users management</h3>

<p>First, change the <strong>root password</strong>:</p>

<pre><code>passwd
</code></pre>

<p>Then you can add a new user so that after we can allow this new user to log in via <strong>ssh</strong> and <strong>disallow root login</strong>.</p>

<pre><code>adduser johnsnow
</code></pre>

<p>We now have to give some permissions to this new user. Edit the corresponding file with:</p>

<pre><code>visudo
</code></pre>

<p>And add this line:</p>

<pre><code>johnsnow ALL=(ALL:ALL) ALL
</code></pre>

<h3>SSH hardening</h3>

<p>Edit the related configuration file. I always use <code>nano</code> but you can use <code>vi</code> or any other editor of your choice.</p>

<pre><code>nano /etc/ssh/sshd_config
</code></pre>

<p>Add or change these lines:</p>

<pre><code>Port xxxxx
Protocol 2
PermitRootLogin no
UseDNS no
AllowUsers johnsnow
DebianBanner no
</code></pre>

<p><code>Port</code>: you can choose any unused port from 1025 up to 65536, this is the port you&rsquo;ll use to log in via ssh, instead of the standard port 22.
This makes it harder for someone to try to log in on your server.</p>

<p><code>Protocol 2</code>: tells ssh to use SSHv2 instead of SSHv1, see <a href="http://www.snailbook.com/faq/ssh-1-vs-2.auto.html">SSHv1 vs SSHv2</a> for a list of the differences.</p>

<p><code>PermitRootLogin no</code>: disables the login via ssh using <strong>root</strong>.</p>

<p><code>UseDNS no</code>: this option is probably the least important one, check it out here
<a href="http://unix.stackexchange.com/questions/56941/what-is-the-point-of-sshd-usedns-option">What is the Point of sshd UseDNS Option</a>.</p>

<p><code>AllowUsers johnsnow</code>: makes <strong>johnsnow</strong> the only user allowed to log in via ssh.</p>

<p><code>DebianBanner no</code>: prevents ssh from broadcasting the distribution information, more information here
<a href="https://scottlinux.com/2011/06/14/disable-debian-banner-suffix-on-ssh-server/">Disable Debian Banner Suffix on ssh Server</a>.</p>

<p>Then you just have to <code>reload</code> ssh:</p>

<pre><code>reload ssh
</code></pre>

<p>That&rsquo;s it, you&rsquo;re done, you can no longer log in using <strong>root</strong>. Now, you can do it using your user like so:</p>

<pre><code>ssh johnsnow@your_server_ip_address -p xxxxx
</code></pre>

<p><code>xxxxx</code> being the port you chose earlier in the configuration.</p>

<h3>Firewall setup</h3>

<p>Next we are going to set up a firewall that&rsquo;s called UFW as in <strong>Uncomplicated Firewall</strong>.</p>

<pre><code>apt-get install ufw
</code></pre>

<p>And we are going to allow the port we use for <strong>ssh</strong>, <strong>http</strong> and <strong>https</strong> protocols.</p>

<pre><code>ufw allow xxxxx
ufw allow http
ufw allow https
</code></pre>

<p><code>xxxxx</code> still being our ssh port.</p>

<p>Now we just have to enable the firewall with:</p>

<pre><code>ufw allow enable
</code></pre>

<p>Now open a second shell and try logging in again via ssh to be sure you didn&rsquo;t break anything with the firewall rules.</p>

<p>You can check everything with:</p>

<pre><code>ufw status verbose
</code></pre>

<h3>Shared memory</h3>

<p>To quote the tutorial I followed: <em>&ldquo;shared memory can be used in an attack against a running service&rdquo;</em>. To secure it, just edit the <strong>fstab</strong> file.</p>

<pre><code>nano /etc/fstab
</code></pre>

<p>And add this line:</p>

<pre><code>tmpfs     /dev/shm     tmpfs     defaults,noexec,nosuid     0     0
</code></pre>

<p>This works on Ubuntu 12.04, for later versions, replace <code>/dev/shm</code> by <code>/run/shm</code>. Just save and reboot.</p>

<h3>Network security</h3>

<p>Edit the <strong>sysctl</strong> file:</p>

<pre><code>nano /etc/sysctl.conf
</code></pre>

<p>And add or change the following lines:</p>

<pre><code># IP Spoofing protection
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1

# Ignore ICMP broadcast requests
net.ipv4.icmp_echo_ignore_broadcasts = 1

# Disable source packet routing
net.ipv4.conf.all.accept_source_route = 0
net.ipv6.conf.all.accept_source_route = 0 
net.ipv4.conf.default.accept_source_route = 0
net.ipv6.conf.default.accept_source_route = 0

# Ignore send redirects
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0

# Block SYN attacks
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_syn_backlog = 2048
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_syn_retries = 5

# Log Martians
net.ipv4.conf.all.log_martians = 1
net.ipv4.icmp_ignore_bogus_error_responses = 1

# Ignore ICMP redirects
net.ipv4.conf.all.accept_redirects = 0
net.ipv6.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0 
net.ipv6.conf.default.accept_redirects = 0

# Ignore Directed pings
net.ipv4.icmp_echo_ignore_all = 1
</code></pre>

<p>To reload the configuration, just issue:</p>

<pre><code>sysctl -p
</code></pre>

<h3>IP Spoofing</h3>

<p>To prevent this, edit the <strong>host</strong> file:</p>

<pre><code>nano /etc/host.conf
</code></pre>

<p>And add these lines:</p>

<pre><code>order bind,hosts
nospoof on
</code></pre>

<h3>DenyHosts</h3>

<p>To quote the tutorial I followed once again: <em>&ldquo;denyHosts is a python program that automatically blocks SSH attacks by adding entries to /etc/hosts.deny.
DenyHosts will also inform Linux administrators about offending hosts, attacked users and suspicious logins&rdquo;</em>.</p>

<p>Install the program:</p>

<pre><code>apt-get install denyhosts
</code></pre>

<p>If you have to edit email settings or other options, you can edit the following file:</p>

<pre><code>nano /etc/denyhosts.conf
</code></pre>

<h3>Fail2Ban</h3>

<p>Fail2Ban listens for failed attemps of connections, exploits etc.. and blocks corresponding IP addresses by updating the firewall rules dynamically.<br/>
To install it, just use the usual:</p>

<pre><code>apt-get install fail2ban
</code></pre>

<p>Edit the configuration file and change the ssh port to the one you are using in the &ldquo;ssh&rdquo; section of the file.</p>

<pre><code>nano /etc/fail2ban/jail.conf
</code></pre>

<p>Change <code>port = ssh</code> to <code>port = xxxxx</code>.</p>

<p>And finally, restart Fail2Ban with:</p>

<pre><code>service fail2ban restart
</code></pre>

<h3>Rootkits</h3>

<p>To finish with security we are going to install programs that check the server for rootkits. A rootkit is a software that has been built to hide processes or
programs and grant them privileged access.</p>

<p>Install two programs:</p>

<pre><code>apt-get install rkhunter chkrootkit
</code></pre>

<p>Update and run the first one:</p>

<pre><code>rkhunter --update
rkhunter --propupd
rkhunter --check
</code></pre>

<p>Just run the second one:</p>

<pre><code>chkrootkit
</code></pre>

<h3>AppArmor</h3>

<p>I&rsquo;ll let Wikipedia describe what it does: <a href="http://en.wikipedia.org/wiki/AppArmor">http://en.wikipedia.org/wiki/AppArmor</a>.</p>

<pre><code>apt-get install apparmor apparmor-profiles
</code></pre>

<h2>SWAP</h2>

<p>If you have a limited RAM, say 512M, you might want to add some swap just in case.<br/>
First check that you do not have swap already in use:</p>

<pre><code>swapon -s
</code></pre>

<p>If this results in an empty list, then you&rsquo;re good.<br/>
You can now create the swapfile and setup a swap area with it:</p>

<pre><code>dd if=/dev/zero of=/swapfile bs=1024 count=512k
mkswap /swapfile
</code></pre>

<p>Now you can enable the file:</p>

<pre><code>swapon /swapfile
</code></pre>

<p>Run the first command to see what changed:</p>

<pre><code>swapon -s
</code></pre>

<p>You should see a new line in the list.<br/>
Now we have to edit <strong>/etc/fstab</strong> file so that these changes still work after a reboot:</p>

<pre><code>nano /etc/fstab
</code></pre>

<p>And add this line:</p>

<pre><code>/swapfile       none    swap    sw      0       0
</code></pre>

<p>Now we have to choose when the system should use this swap space instead of using RAM. For this we have to choose a value between 0 and 100 that&rsquo;s going to be the
left percentage of RAM before using swap. For instance, if we have 512M RAM and we set the value to 10, it means the system will start using swap when we have
less than 10% of RAM available, or if you prefere less than 50M available. Here we set the value to <strong>0</strong>, this means the system will swap only in case of emergency
at the last moment. I personnaly had to set it to <strong>20</strong> for the assets precompilation to work, otherwise I was running into an error (the only indication was
&ldquo;<em>killed</em>&rdquo;).</p>

<pre><code>echo 0 | sudo tee /proc/sys/vm/swappiness
echo vm.swappiness = 0 | sudo tee -a /etc/sysctl.conf
</code></pre>

<p>Just set permissions on the file and you&rsquo;re done:</p>

<pre><code>sudo chown root:root /swapfile 
sudo chmod 0600 /swapfile
</code></pre>

<h2>Nginx and Unicorn</h2>

<h3>RVM, MongoDB, Redis and other stuff</h3>

<p>Before actually installing and configuring Nginx and Unicorn, we&rsquo;re going to install <strong>rvm</strong>, <strong>git</strong>, and <strong>nodejs</strong>.<br/>
First, let&rsquo;s install <strong>curl</strong>:</p>

<pre><code>apt-get install curl
</code></pre>

<p>And <strong>rvm</strong>:</p>

<pre><code>curl -L get.rvm.io | bash -s stable
</code></pre>

<p>Then make it available in your current shell:</p>

<pre><code>source ~/.rvm/scripts/rvm
</code></pre>

<p>And install the requirements:</p>

<pre><code>rvm requirements
</code></pre>

<p>Install the ruby version your are using in your application, for instance 2.0.0, and make it the default for the system:</p>

<pre><code>rvm install 2.0.0
rvm use 2.0.0 --default
</code></pre>

<p>Update <strong>rubygems</strong> just in case:</p>

<pre><code>rvm rubygems current
</code></pre>

<p>Install git:</p>

<pre><code>apt-get install git-core
</code></pre>

<p>I usually install <strong>NodeJS</strong> for assets precompilation:</p>

<pre><code>apt-get install nodejs
</code></pre>

<p>Let&rsquo;s install <strong>MongoDB</strong>:</p>

<pre><code>apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10
echo 'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen' | sudo tee /etc/apt/sources.list.d/mongodb.list
apt-get update
apt-get install mongodb-10gen
</code></pre>

<p>We have to create the default <strong>/data/db</strong> directory and set the owner and permissions accordingly:</p>

<pre><code>mkdir -p /data/db
chmod 0755 /data/db
chown mongodb /data/db
</code></pre>

<p>Let&rsquo;s install <strong>Redis</strong> now (for sidekiq):</p>

<pre><code>apt-get install redis-server
</code></pre>

<p>And we&rsquo;re going to need <strong>bundler</strong> too:</p>

<pre><code>gem install bundler
</code></pre>

<p>Finally, at some point, chances are that you&rsquo;re going to install some gem requiring <strong>Nokogiri</strong> which requires additional packages, so let&rsquo;s install those
packages beforehand:</p>

<pre><code>apt-get install libxslt-dev libxml2-dev
</code></pre>

<h3>Nginx</h3>

<p>It&rsquo;s now time to install <strong>Nginx</strong> and run it:</p>

<pre><code>apt-get install nginx
service nginx start
</code></pre>

<p>Now if you navigate to your_server_ip_address in a browser, you should see the default Nginx page.</p>

<p>Let&rsquo;s configure it. Add this in <strong>/etc/nginx/nginx.conf</strong>, in the <strong>http { &hellip; }</strong> block:</p>

<pre><code>upstream unicorn {
  server unix:/tmp/unicorn.your_project.sock fail_timeout=0;
}

server {
  listen 80 default_server deferred;
  # server_name example.com;
  root /home/johnsnow/apps/your_project/current/public;

  location ^~ /assets/ {
    gzip_static on;
    expires max;
    add_header Cache-Control public;
  }

  try_files $uri/index.html $uri @unicorn;
  location @unicorn {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://unicorn;
  }

  error_page 500 502 503 504 /500.html;
  client_max_body_size 20M;
  keepalive_timeout 10;
}
</code></pre>

<p>Let&rsquo;s break it down:</p>

<p>The <code>upstream</code> block will be used to proxy requests to a Unicorn unix socket (a socket used by Unicorn to listen and process requests). Right now there is no
socket yet but we&rsquo;ll be configuring this later on. Then we use this in the <code>server</code> block with the line <code>proxy_pass http://unicorn</code>.</p>

<p>The <code>root</code> line is used to point to the <strong>public</strong> directory of the Rails app. This path structure is the one set up by <strong>Capistrano</strong> when deploying the
application.</p>

<p>The <code>client_max_body_size</code> directive is used to set the maximum body size of client requests. Check it out here:
<a href="http://wiki.nginx.org/HttpCoreModule#client_max_body_size">http://wiki.nginx.org/HttpCoreModule#client_max_body_size</a>.</p>

<p>You can look the internet up for the rest of these options, you&rsquo;ll find way more information than what I could write here.</p>

<h3>Unicorn</h3>

<p>Add the <strong>unicorn</strong> gem to your project: in the Gemfile, add</p>

<p>``` ruby Gemfile</p>

<h1>I am currently using version 4.8.0</h1>

<p>gem &lsquo;unicorn&rsquo;, &lsquo;~> 4.8.0&rsquo;
```</p>

<p>We&rsquo;re going to create the configuration file for <strong>Unicorn</strong>: in your application, create a file <strong>config/unicorn.rb</strong>:</p>

<p>``` ruby config/unicorn.rb
root = &ldquo;/home/johnsnow/apps/your_project/current&rdquo;
working_directory root
pid &ldquo;#{root}/tmp/pids/unicorn.pid&rdquo;
stderr_path &ldquo;#{root}/log/unicorn.log&rdquo;
stdout_path &ldquo;#{root}/log/unicorn.log&rdquo;</p>

<p>listen &ldquo;/tmp/unicorn.your_project.sock&rdquo;
worker_processes 2
timeout 30</p>

<h1>Force the bundler gemfile environment variable to</h1>

<h1>reference the capistrano &ldquo;current&rdquo; symlink</h1>

<p>before_exec do |_|
  ENV[&ldquo;BUNDLE_GEMFILE&rdquo;] = File.join(root, &lsquo;Gemfile&rsquo;)
end
```</p>

<p>And an initialization script for <strong>Unicorn</strong> as well in <strong>config/unicorn_init.sh</strong>, this file will be symlinked later in <strong>/etc/init.d/</strong>:</p>

<p>``` bash config/unicorn_init.sh</p>

<h1>!/bin/sh</h1>

<h3>BEGIN INIT INFO</h3>

<h1>Provides:          unicorn</h1>

<h1>Required-Start:    $remote_fs $syslog</h1>

<h1>Required-Stop:     $remote_fs $syslog</h1>

<h1>Default-Start:     2 3 4 5</h1>

<h1>Default-Stop:      0 1 6</h1>

<h1>Short-Description: Manage unicorn server</h1>

<h1>Description:       Start, stop, restart unicorn server for a specific application.</h1>

<h3>END INIT INFO</h3>

<p>set -e</p>

<h1>Feel free to change any of the following variables for your app:</h1>

<p>TIMEOUT=${TIMEOUT-60}
APP_ROOT=/home/johnsnow/apps/your_project/current
PID=$APP_ROOT/tmp/pids/unicorn.pid
CMD=&ldquo;cd $APP_ROOT; bundle exec unicorn -D -c $APP_ROOT/config/unicorn.rb -E production&rdquo;
AS_USER=johnsnow
set -u</p>

<p>OLD_PIN=&ldquo;$PID.oldbin&rdquo;</p>

<p>sig () {
  test -s &ldquo;$PID&rdquo; &amp;&amp; kill &ndash;$1 <code>cat $PID</code>
}</p>

<p>oldsig () {
  test -s $OLD_PIN &amp;&amp; kill &ndash;$1 <code>cat $OLD_PIN</code>
}</p>

<p>run () {
  if [ &ldquo;$(id -un)&rdquo; = &ldquo;$AS_USER&rdquo; ]; then</p>

<pre><code>eval $1
</code></pre>

<p>  else</p>

<pre><code>su -c "$1" - $AS_USER
</code></pre>

<p>  fi
}</p>

<p>case &ldquo;$1&rdquo; in
start)
  sig 0 &amp;&amp; echo >&amp;2 &ldquo;Already running&rdquo; &amp;&amp; exit 0
  run &ldquo;$CMD&rdquo;
  ;;
stop)
  sig QUIT &amp;&amp; exit 0
  echo >&amp;2 &ldquo;Not running&rdquo;
  ;;
force-stop)
  sig TERM &amp;&amp; exit 0
  echo >&amp;2 &ldquo;Not running&rdquo;
  ;;
restart|reload)
  sig HUP &amp;&amp; echo reloaded OK &amp;&amp; exit 0
  echo >&amp;2 &ldquo;Couldn&rsquo;t reload, starting &lsquo;$CMD&rsquo; instead&rdquo;
  run &ldquo;$CMD&rdquo;
  ;;
upgrade)
  if sig USR2 &amp;&amp; sleep 2 &amp;&amp; sig 0 &amp;&amp; oldsig QUIT
  then</p>

<pre><code>n=$TIMEOUT
while test -s $OLD_PIN &amp;&amp; test $n -ge 0
do
  printf '.' &amp;&amp; sleep 1 &amp;&amp; n=$(( $n - 1 ))
done
echo

if test $n -lt 0 &amp;&amp; test -s $OLD_PIN
then
  echo &gt;&amp;2 "$OLD_PIN still exists after $TIMEOUT seconds"
  exit 1
fi
exit 0
</code></pre>

<p>  fi
  echo >&amp;2 &ldquo;Couldn&rsquo;t upgrade, starting &lsquo;$CMD&rsquo; instead&rdquo;
  run &ldquo;$CMD&rdquo;
  ;;
reopen-logs)
  sig USR1
  ;;
*)
  echo >&amp;2 &ldquo;Usage: $0 &lt;start|stop|restart|upgrade|force-stop|reopen-logs>&rdquo;
  exit 1
  ;;
esac
```</p>

<p>The file is pretty much straightforward so I suggest you read it and see what it does. Basically, it is used to manage the unicorn process.</p>

<h3>Capistrano</h3>

<p>Add the required gems to your Gemfile:</p>

<p><code>ruby Gemfile
gem 'capistrano', '~&gt; 2.15.4'
gem 'rvm-capistrano', '~&gt; 1.5.1'
</code></p>

<p>Now we create two files for Capistrano: <strong>Capfile</strong> and <strong>config/deploy.rb</strong> with the following command ran from the root directory of your app:</p>

<pre><code>capify .
</code></pre>

<p>As a side note, before we go further, I&rsquo;m supposing that you already have the mongoid gem or whatever ORM you&rsquo;re using and the sidekiq gem if you are using
sidekiq as well.</p>

<p>Let&rsquo;s write some instructions in the <strong>config/deploy.rb</strong> file:</p>

<p>``` ruby config/deploy.rb
require &ldquo;bundler/capistrano&rdquo;
require &ldquo;rvm/capistrano&rdquo;
require &lsquo;sidekiq/capistrano&rsquo;</p>

<p>server &ldquo;your_server_ip_address&rdquo;, :web, :app, :db, primary: true</p>

<p>set :application, &ldquo;your_project&rdquo;
set :user, &ldquo;johnsnow&rdquo;
set :port, xxxxx #your ssh port
set :deploy_to, &ldquo;/home/#{user}/apps/#{application}&rdquo;
set :deploy_via, :remote_cache
set :use_sudo, false</p>

<p>set :scm, &ldquo;git&rdquo;
set :repository, &ldquo;your_project.git&rdquo; #your application repo (for instance git@github.com:user/application.git)
set :branch, &ldquo;master&rdquo;</p>

<p>default_run_options[:pty] = true
ssh_options[:forward_agent] = true</p>

<p>after &ldquo;deploy&rdquo;, &ldquo;deploy:cleanup&rdquo; # keep only the last 5 releases</p>

<p>namespace :deploy do
  %w[start stop restart].each do |command|</p>

<pre><code>desc "#{command} unicorn server"
task command, roles: :app, except: { no_release: true } do
  run "/etc/init.d/unicorn_#{application} #{command}"
end
</code></pre>

<p>  end</p>

<p>  task :setup_config, roles: :app do</p>

<pre><code># symlink the unicorn init file in /etc/init.d/
sudo "ln -nfs #{current_path}/config/unicorn_init.sh /etc/init.d/unicorn_#{application}"
# create a shared directory to keep files that are not in git and that are used for the application
run "mkdir -p #{shared_path}/config"
# if you're using mongoid, create a mongoid.template.yml file and fill it with your production configuration
# and add your mongoid.yml file to .gitignore
put File.read("config/mongoid.template.yml"), "#{shared_path}/config/mongoid.yml"
puts "Now edit the config files in #{shared_path}."
</code></pre>

<p>  end
  after &ldquo;deploy:setup&rdquo;, &ldquo;deploy:setup_config&rdquo;</p>

<p>  task :symlink_config, roles: :app do</p>

<pre><code># symlink the shared mongoid config file in the current release
run "ln -nfs #{shared_path}/config/mongoid.yml #{release_path}/config/mongoid.yml"
</code></pre>

<p>  end
  after &ldquo;deploy:finalize_update&rdquo;, &ldquo;deploy:symlink_config&rdquo;</p>

<p>  desc &ldquo;Create MongoDB indexes&rdquo;
  task :mongoid_indexes do</p>

<pre><code>run "cd #{current_path} &amp;&amp; RAILS_ENV=production bundle exec rake db:mongoid:create_indexes", once: true
</code></pre>

<p>  end
  after &ldquo;deploy:update&rdquo;, &ldquo;deploy:mongoid_indexes&rdquo;</p>

<p>  desc &ldquo;Make sure local git is in sync with remote.&rdquo;
  task :check_revision, roles: :web do</p>

<pre><code>unless `git rev-parse HEAD` == `git rev-parse origin/master`
  puts "WARNING: HEAD is not the same as origin/master"
  puts "Run `git push` to sync changes."
  exit
end
</code></pre>

<p>  end
  before &ldquo;deploy&rdquo;, &ldquo;deploy:check_revision&rdquo;
end
```</p>

<p>I&rsquo;ve added some comments but feel free to read the rest of the file, it is straightforward as well.</p>

<p>Your <strong>Capfile</strong> should look like this:</p>

<p><code>ruby Capfile
load 'deploy'
load 'deploy/assets'
load 'config/deploy'
</code></p>

<p>Add your ssh key to the authorized keys on your server:</p>

<pre><code># replace the port, the user and your ip address accordingly
cat ~/.ssh/id_rsa.pub | ssh -p xxxxx johnsnow@your_server_ip_address 'mkdir -p ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys'
</code></pre>

<p>Make sure you pushed all your changes to your repository (on Github or Bitbucket for instance).</p>

<p>Now we have to tell capistrano to create the initial directory structure on the server as described in the recipe we just created:</p>

<pre><code>cap deploy:setup
</code></pre>

<p>You can now go to your server and edit the <strong>mongoid.yml</strong> file in <strong>/home/johnsnow/apps/your_project/shared/config/mongoid.yml</strong>.</p>

<p>Then you&rsquo;ll have to run:</p>

<pre><code>cap deploy:cold
</code></pre>

<p>From the documentation, this will deploy the code, run any pending migrations (not used here because it&rsquo;s MongoDB), and then instead of invoking
<code>deploy:restart</code>, it will invoke <code>deploy:start</code> to fire up the application servers. Check it out here
<a href="http://capitate.rubyforge.org/recipes/deploy.html">http://capitate.rubyforge.org/recipes/deploy.html</a>.</p>

<p>Delete the default Nginx server block:</p>

<pre><code>rm /etc/nginx/sites-enabled/default
</code></pre>

<p>You can restart the <strong>nginx</strong> service to make sure the changes are taken into account:</p>

<pre><code>service nginx restart
</code></pre>

<p>Make sure <strong>Unicorn</strong> is restarted when rebooting the server:</p>

<pre><code>update-rc.d -f unicorn_your_project defaults
</code></pre>

<p>Push your changes (locally) one last time and deploy:</p>

<pre><code>git push
cap deploy
</code></pre>

<p>That&rsquo;s it, your app should be up and running when typing your server&rsquo;s ip address in your browser!</p>

<h2>Sidekiq</h2>

<p>We already required sidekiq in the capistrano recipe so everything should be fine but what if we restart the server? Let&rsquo;s create a script to make sure all the
processes properly restart when rebooting. This script is made to work with <strong>Upstart</strong>.</p>

<p>Create a file <strong>/etc/init/sidekiq.conf</strong>:</p>

<p>``` bash /etc/init/sidekiq.conf</p>

<h1>/etc/init/sidekiq.conf &ndash; Sidekiq config</h1>

<h1>This example config should work with Ubuntu 12.04+.  It</h1>

<h1>allows you to manage multiple Sidekiq instances with</h1>

<h1>Upstart, Ubuntu&rsquo;s native service management tool.</h1>

<p>#</p>

<h1>Save this config as /etc/init/sidekiq.conf then manage sidekiq with:</h1>

<h1>sudo start sidekiq index=0</h1>

<h1>sudo stop sidekiq index=0</h1>

<h1>sudo status sidekiq index=0</h1>

<p>#</p>

<h1>or use the service command:</h1>

<h1>sudo service sidekiq {start,stop,restart,status}</h1>

<p>#</p>

<p>description &ldquo;Sidekiq Background Worker&rdquo;</p>

<h1>no &ldquo;start on&rdquo;, we don&rsquo;t want to automatically start</h1>

<p>stop on (stopping workers or runlevel [06])</p>

<h1>change to match your deployment user</h1>

<p>setuid johnsnow
setgid johnsnow</p>

<p>respawn
respawn limit 3 30</p>

<h1>TERM and USR1 are sent by sidekiqctl when stopping sidekiq.  Without declaring these as normal exit codes, it just respawns.</h1>

<p>normal exit 0 TERM USR1</p>

<h1>instance $index</h1>

<p>script</p>

<h1>this script runs in /bin/sh by default</h1>

<h1>respawn as bash so we can source in rbenv</h1>

<p>exec /bin/bash &lt;<EOT
  # use syslog for logging
  # exec &> /dev/kmsg</p>

<p>  # pull in system rbenv
  # export HOME=/home/deploy
  # source /etc/profile.d/rbenv.sh</p>

<p>  cd /home/johnsnow/apps/your_project/current
  nohup bundle exec sidekiq -e production -C config/sidekiq.yml -i 0 -P tmp/pids/sidekiq.pid >> log/sidekiq.log 2>&amp;1 &amp;
EOT
end script
```</p>

<p>Here are the options for the line starting with <code>nohup</code>:<br/>
<code>-e</code>: the environment<br/>
<code>-C</code>: a config file eventhough we do not have one<br/>
<code>-i</code>: sidekiq process index, from 0 to whatever you want, you&rsquo;ll have to loop and increment the value if you want to create multiple processes<br/>
<code>-P</code>: the file holding sidekiq&rsquo;s process id</p>

<p><code>nohup</code> is used to run sidekiq in the background and therefore keeping it alive event after logging off.</p>

<p>I took the line from this file, check it out:
<a href="https://github.com/mperham/sidekiq/blob/master/lib/sidekiq/capistrano2.rb">https://github.com/mperham/sidekiq/blob/master/lib/sidekiq/capistrano2.rb</a>.</p>

<h2>Setup daily MongoDB backups</h2>

<p>You&rsquo;ll often want to setup backups so here we go: just create a directory to store these backups.</p>

<pre><code>mkdir /home/johnsnow/dumps
</code></pre>

<p>Then create a script to actually make a dump:</p>

<p>``` bash /home/johnsnow/mongodump</p>

<h1>!/bin/bash</h1>

<p>DUMPPATH=/home/johnsnow/dumps # dumps directory we just created
MONGODBNAME=your_project_production # your MongoDB database name
DAY=<code>/bin/date +%Y%m%d</code> # today&rsquo;s datetime</p>

<p>mongodump &mdash;db $MONGODBNAME &mdash;out $DUMPPATH/mongo<em>$DAY # run the command we those variables set
cd $DUMPPATH/mongo</em>$DAY # navigate to the folder where the dump was saved
tar -cvzf &ldquo;$DUMPPATH/mongo_$DAY.tar&rdquo; $MONGODBNAME # create an archive out of that dump</p>

<p>cd $DUMPPATH
rm -rf $DUMPPATH/mongo_$DAY # remove the dump because we only keep the archive version
```</p>

<p>Next make it executable:</p>

<pre><code>chmod +x mongodump
</code></pre>

<p>And create a cronjob:</p>

<pre><code>sudo crontab -e

# add the next line in the file
@daily /home/raindal/mongodump
</code></pre>

<p><code>@daily</code> means the script will be executed everyday at midnight.</p>

<p>That&rsquo;s it for backups!</p>

<h2>The end</h2>

<p>I hope it helps! If I forgot something, be sure to leave a comment below and I&rsquo;ll try to answer as quickly as I can.</p>

<p>Just in case you run in the same problems I did, I had to run another <code>update-rc.d -f unicorn_your_project defaults</code> at the end in order to have unicorn restarting
on server reboot. The second error was hapenning when I was deploying the application with <code>cap deploy</code> and the only indication was &ldquo;<em>killed</em>&rdquo; just in the
middle of the assets precompilation. To fix this I just had to set up some swap space because I was lacking memory.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails 4 and Batman.js - Another Getting Started Tutorial]]></title>
    <link href="http://requiremind.com/ruby-on-rails-4-and-batman-dot-js-another-getting-started-tutorial"/>
    <updated>2013-10-06T22:08:00+02:00</updated>
    <id>http://requiremind.com/ruby-on-rails-4-and-batman-dot-js-another-getting-started-tutorial</id>
    <content type="html"><![CDATA[<p>I’ve never been using JS frameworks before, this is why I wanted to give it a shot. Many options here: AngularJS, Ember.js, Backbone.js, etc, makes the choice pretty hard
when you don’t know the subtleties of each. As a Rails developer, I chose Batman.js because of its “Rails orientation” and because I know that <a href="http://www.shopify.ca/">Shopify</a> folks here in Canada
are working hard to make things easy for us Rails developers (yes, they are developing Batman.js).</p>

<!-- more -->


<p>Throughout this tutorial I’m going to show you how I quickly built a simple post/comments application with Ruby on Rails 4 and Batman.js.</p>

<p>At the time I’m writing these lines, our friends of Gotham City are updating the <a href="http://batmanjs.org/docs/index.html">documentation</a>, so be sure to check it out: a lot of helpful, valuable resources.</p>

<p>You can find the application github repo here: <a href="https://github.com/Raindal/batman_js_blog">https://github.com/Raindal/batman_js_blog</a>.</p>

<p>I’m eager to better myself with the framework so any comment will be highly appreciated.</p>

<p>Let’s dive in!</p>

<h2>On the server side</h2>

<p>Here I’m assuming that you already installed Rails 4. We’re first going to create a new application called <strong>batman_js_blog</strong>.
Let’s skip the documentation part with the following line.</p>

<pre><code>rails new batman_js_blog --no-ri --no-rdoc
</code></pre>

<p>And just to be clear, <code>cd</code> into the application.</p>

<pre><code>cd batman_js_blog
</code></pre>

<blockquote><p>Tired of using <code>cd</code> everytime? Check out <a href="http://requiremind.com/why-i-love-my-development-environment">my previous post</a> and start using ZSH now!</p></blockquote>

<h3>The models</h3>

<p>The models are pretty simple, the posts will have a <strong>title</strong> and a <strong>content</strong>. The comments will have a <strong>content</strong> only and a reference to a post (<strong>post_id</strong>).</p>

<pre><code>rails g model post title:string content:text
rails g model comment content:text post:references
</code></pre>

<p>Let’s get the associations right: a post <em>has many</em> comments, therefore, a comment <em>belongs to</em> a post. Let’s create some validations for future usage
(see <em>Errors Handling</em> at the end).</p>

<p>``` ruby app/models/post.rb
class Post &lt; ActiveRecord::Base
  has_many :comments</p>

<p>  validates :title,   presence: true
  validates :content, presence: true
end
```</p>

<p>Using <code>references</code> when generating the Comment model should already get this part right with the <code>belongs_to</code>:</p>

<p><code>ruby app/models/comment.rb
class Comment &lt; ActiveRecord::Base
  belongs_to :post
end
</code></p>

<p>Run the migrations to create both tables, as usual.</p>

<pre><code>rake db:migrate
</code></pre>

<p>We’re going to create some seeds to populate the database with fake data to work with. Let’s create 20 posts with 5 comments each.</p>

<p><code>ruby db/seeds.rb
20.times do |i|
  post = Post.create(title: "Post #{i}", content: "Some awesome content")
  5.times { |j| post.comments.create(content: "Comment n°#{j}") }
end
</code></p>

<p>Run the seeds.</p>

<pre><code>rake db:seed
</code></pre>

<p>Here we are using nested routes (nested resources) to reflect the associations we created earlier.<br/>
This will enable routes like /posts/:post_id/comments/:id.</p>

<p><code>ruby config/routes.rb
resources :posts do
  resources :comments
end
</code></p>

<h3>The controllers</h3>

<p>First you can create a <strong>posts_controller.rb</strong> file in your controllers folder.</p>

<p>As we only need to serve <strong>json</strong>, we’re going to use the handy <code>respond_to</code> method at the top of our controller. Then, in every action we only have to use <code>respond_with</code>,
that will basically call <code>to_json</code> on our resources.</p>

<p>When displaying a specific post, we want to display its comments as well, so we need to return them with the post, this is why we use <code>include: :comments</code> in the show action.</p>

<p>We do not need the <code>new</code> and <code>edit</code> actions, because Batman.js will take care of showing the form for us (it can because those actions do not require an interaction
with the database).</p>

<p>The rest of the controller is pretty much straightforward if you know your way around with Rails (which I assume).</p>

<p>``` ruby app/controllers/posts_controller.rb
class PostsController &lt; ApplicationController
  respond_to :json</p>

<p>  def index</p>

<pre><code>respond_with Post.all
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>respond_with Post.find(params[:id]), include: :comments
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>respond_with Post.create(post_params)
</code></pre>

<p>  end</p>

<p>  def update</p>

<pre><code>post = Post.find(params[:id])
post.update_attributes(post_params)
respond_with post
</code></pre>

<p>  end</p>

<p>  def destroy</p>

<pre><code>respond_with Post.find(params[:id]).destroy
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def post_params
  params.require(:post).permit(:title, :content)
end
</code></pre>

<p>end
```</p>

<p>The comments controller is rather simple too. We’re not going to list all the comments, neither are we going to show one comment on its own,
we’re not allowing the edition of a comment either. That means we don’t need the index, show, and update actions.</p>

<p>The only thing we want to do is display related comments on every post&rsquo;s show view and a small form for adding a comment (plus a link for destroying each post).<br/>
As I stated before, the comments are returned with every post thanks to <code>include: :comments</code> so we don&rsquo;t have to take care of this. The only thing left to do is enable
comments creation and destruction.</p>

<p>You can create a <strong>comments_controller.rb</strong> file:</p>

<p>``` ruby app/controllers/comments_controller.rb
class CommentsController &lt; ApplicationController
  respond_to :json</p>

<p>  def create</p>

<pre><code>post = Post.find(params[:post_id])
comment = post.comments.build(comment_params)
comment.save
respond_with(post, comment)
</code></pre>

<p>  end</p>

<p>  def destroy</p>

<pre><code>comment = Comment.find(params[:id])
respond_with(comment.post, comment.destroy)
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def comment_params
  params.require(:comment).permit(:content)
end
</code></pre>

<p>end
```</p>

<p>You can now run a server with <code>rails s</code> and navigate to <a href="http://localhost:3000/posts.json">http://localhost:3000/posts.json</a> to check that you do have a json posts list displayed.
You can check that each post is returned with its associated comments by navigating to <a href="http://localhost:3000/posts/1.json">http://localhost:3000/posts/1.json</a>.</p>

<h2>On the client side</h2>

<p>Now we can really crack into the subject. First of all, let’s add the gem to our gemfile and run <code>bundle</code> to install it.</p>

<p>``` ruby Gemfile
source &lsquo;<a href="https://rubygems.org">https://rubygems.org</a>&rsquo;</p>

<h1>Bundle edge Rails instead: gem &lsquo;rails&rsquo;, github: &lsquo;rails/rails&rsquo;</h1>

<p>gem &lsquo;rails&rsquo;, &lsquo;4.0.0&rsquo;</p>

<p>gem &lsquo;batman-rails&rsquo;</p>

<p>&hellip;
```</p>

<pre><code>bundle
</code></pre>

<p>We can now generate the skeleton of our Batman.js app, it’s going to reside in <strong>app/assets/batman</strong>.</p>

<pre><code>rails g batman:app
</code></pre>

<p>This created the following folders and files:</p>

<pre><code>create  app/controllers/batman_controller.rb
create  app/views/layouts/batman.html.erb
insert  config/routes.rb
create  app/assets/batman/batman_js_blog.js.coffee
create  app/assets/batman/models
create  app/assets/batman/models/.gitkeep
create  app/assets/batman/views
create  app/assets/batman/views/.gitkeep
create  app/assets/batman/controllers
create  app/assets/batman/controllers/.gitkeep
create  app/assets/batman/html
create  app/assets/batman/html/.gitkeep
create  app/assets/batman/lib
create  app/assets/batman/lib/.gitkeep
create  app/assets/batman/html/main
create  app/assets/batman/controllers/application_controller.js.coffee
create  app/assets/batman/controllers/main_controller.js.coffee
create  app/assets/batman/html/main/index.html
create  app/assets/batman/views/main/main_index_view.js.coffee
prepend  app/assets/batman/batman_js_blog.js.coffee
prepend  app/assets/batman/batman_js_blog.js.coffee
prepend  app/assets/batman/batman_js_blog.js.coffee
prepend  app/assets/batman/batman_js_blog.js.coffee
</code></pre>

<p>You can navigate to <a href="http://localhost:3000">http://localhost:3000</a> to see Batman.js home page.</p>

<h3>Sneak peek</h3>

<p>If you open the <strong>index view</strong>, you&rsquo;re probably going to see something like this somewhere in the file:</p>

<p>``` html app/assets/batman/html/main/index.html</p>

<div><label>First Name:</label><input type="text" data-bind="firstName"></div>


<div><label>Last Name:</label><input type="text" data-bind="lastName"></div>


<div data-showif="hasName">Hello, my name is <span data-bind="fullName"></span></div>


<div><button data-event-click="resetName">Reset name</button></div>


<p>```</p>

<p>Ok, now you can finally catch a glimpse of Batman.js&hellip; And I&rsquo;m going to go through each element here.<br/>
Every <code>data</code> property you see here is Batman related and as we speak about a JS framework, each of these properties will apply live all the time.</p>

<p><code>data-bind</code>: binds the element&rsquo;s inner html to the given accessor&rsquo;s value. For instance the first input will display the value returned by <code>firstName</code>.<br/>
<code>data-showif</code>: shows the element depending on the value of <code>hasName</code> which is a boolean.<br/>
<code>data-event-click</code>: triggers the given method upon click.</p>

<p>Now take a look at the controller.</p>

<p>``` coffeescript app/assets/batman/controllers/main_controller.js.coffee
class BatmanJsBlog.MainController extends BatmanJsBlog.ApplicationController
  routingKey: &lsquo;main&rsquo;</p>

<p>  index: (params) &ndash;></p>

<pre><code>@set 'firstName', 'Bruce'
@set 'lastName', 'Wayne'
</code></pre>

<p>  @accessor &lsquo;fullName&rsquo;, &ndash;></p>

<pre><code>"#{@get('firstName')} #{@get('lastName')}"
</code></pre>

<p>```</p>

<p>You can actually see that the initial values are set in the <code>index</code> action using <code>@set('var', 'value')</code>.<br/>
You can also see that the <code>fullName</code> accessor that is used in a <code>data-bind</code> is defined here and returns the values of the <code>firstName</code> and <code>lastName</code> variables combined
with <code>@get('var')</code>.</p>

<p>Now let&rsquo;s see <code>hasName</code> and <code>resetName</code>. These two reside in the following file.</p>

<p>``` coffeescript app/assets/batman/views/main/main_index_view.js.coffee
class BatmanJsBlog.MainIndexView extends Batman.View
  resetName: &ndash;></p>

<pre><code>@controller.set('firstName', '')
@controller.set('lastName', '')
</code></pre>

<p>  @accessor &lsquo;hasName&rsquo;, &ndash;></p>

<pre><code>@controller.get('fullName').length &gt; 1
</code></pre>

<p>```</p>

<p>This code is specific to the index view. <code>hasName</code> checks that <code>fullName</code> contains at least one character and <code>resetName</code> resets tha values of <code>firstName</code> and <code>lastName</code>.</p>

<h3>The models</h3>

<p>We can go and create folders and files for the post resource.</p>

<pre><code>rails g batman:scaffold post
</code></pre>

<p>The last command is a bit overkill for what we want to do but pretty handy for starting the project.</p>

<p>Take a look at the main batman file and change the <code>@root</code> to <code>posts#index</code>.</p>

<p>``` coffeescript app/assets/batman/batman_js_blog.js.coffee
Batman.config.pathToHTML = &lsquo;/assets/html&rsquo;</p>

<p>class BatmanJsBlog extends Batman.App</p>

<p>  # This was automatically generated by the scaffold command
  @resources &lsquo;posts&rsquo;</p>

<p>  # Change &lsquo;main#index&rsquo; to this, this is the landing page of the application
  # We want to first display a list of all the posts
  @root &lsquo;posts#index&rsquo;</p>

<p>(global ? window).BatmanJsBlog = BatmanJsBlog
```</p>

<p>The Post model should look like so:</p>

<p>``` coffeescript app/assets/batman/models/post.js.coffee
class BatmanJsBlog.Post extends Batman.Model
  @resourceName: &lsquo;posts&rsquo;
  @storageKey: &lsquo;posts&rsquo;</p>

<p>  # We are using Batman.js with Ruby on Rails&hellip;
  @persist Batman.RailsStorage</p>

<p>  # Use @encode to tell batman.js which properties Rails will send back with its JSON.
  @encode &lsquo;title&rsquo;, &lsquo;content&rsquo;
  @encodeTimestamps()
```</p>

<p>Let&rsquo;s generate the Comment model.</p>

<pre><code>rails g batman:model comment
</code></pre>

<p>``` coffeescript app/assets/batman/models/comment.js.coffee
class BatmanJsBlog.Comment extends Batman.Model
  @resourceName: &lsquo;comments&rsquo;
  @storageKey: &lsquo;comments&rsquo;</p>

<p>  @persist Batman.RailsStorage</p>

<p>  # Looks familiar&hellip;
  @belongsTo &lsquo;post&rsquo;</p>

<p>  # Pretty much straightforward but we have to specify it
  @urlNestsUnder &lsquo;post&rsquo;</p>

<p>  @encode &lsquo;content&rsquo;, &lsquo;post_id&rsquo;
  @encodeTimestamps()
```</p>

<p>We can now add the association on the Post model side.</p>

<p>``` coffeescript app/assets/batman/models/post.js.coffee
class BatmanJsBlog.Post extends Batman.Model
  @resourceName: &lsquo;posts&rsquo;
  @storageKey: &lsquo;posts&rsquo;</p>

<p>  @persist Batman.RailsStorage</p>

<p>  # Here is the other part of the relation
  @hasMany &lsquo;comments&rsquo;</p>

<p>  @encode &lsquo;title&rsquo;, &lsquo;content&rsquo;
  @encodeTimestamps()
```</p>

<p>We can go back to the main file and set the <strong>nested routes</strong> for posts and comments, which also looks like the syntax you find in a traditional Rails application.</p>

<p>``` coffeescript app/assets/batman/batman_js_blog.js.coffee
&hellip;</p>

<p>class BatmanJsBlog extends Batman.App</p>

<p>  @resources &lsquo;posts&rsquo;, &ndash;></p>

<pre><code>@resources 'comments'
</code></pre>

<p>&hellip;
```</p>

<h3>The controller</h3>

<p>Let&rsquo;s go edit the <strong>posts controller</strong> and create an <code>index</code> action to list all our posts.</p>

<p>``` coffeescript app/assets/batman/controllers/posts_controller.js.coffee
class BatmanJsBlog.PostsController extends BatmanJsBlog.ApplicationController
  routingKey: &lsquo;posts&rsquo;</p>

<p>  index: (params) &ndash;></p>

<pre><code>@set('posts', BatmanJsBlog.Post.get('all'))
</code></pre>

<p>```</p>

<p>Here we are setting a <code>posts</code> variable when going through the <code>index</code> action that contains all our posts.<br/>
<code>BatmanJsBlog.Post.get('all')</code> is a query to our Rails API we created earlier.</p>

<blockquote><p>At any time, just open your browser dev tools to watch requests sent by Batman.js.</p></blockquote>

<p>Now we can modify our <strong>index</strong> view.</p>

<p>``` html app/assets/batman/html/posts/index.html
<span data-bind="'post' | pluralize posts.length"></span></p>

<ul>
  <li data-foreach-post="posts">
    <a data-bind="post.title" data-route="post"></a> |
    <a data-event-click="destroy">Destroy</a>
  </li>
</ul>


<p><code>``
The first line sets a binding to</code>pluralize<code>the word "post" depending on the number of posts being retrieved:</code>posts.length<code>.  
Now look at this line</code><li data-foreach-post="posts"><code>. Here</code>data-foreach<code>will iterate through</code>posts<code>that have been set earlier in the controller and yield a</code>li<code>
tag for each of these posts. In every</code>li<code>block, a variable is used to hold the post object:</code>post<code>as in</code>data-foreach-post<code>.  
</code><a data-bind="post.title" data-route="post"></a><code>: this is a link, again, the html value is set with</code>data-bind<code>and will be the post's title attribute.  
</code>data-route<code>is used to set the</code>href<code>value of the link. Here</code>data-route=&ldquo;post&rdquo;<code>means we are linking to the</code>show<code>action corresponding to the current</code>post<code>.  
We also display a "destroy" link. In Batman.js, the</code>destroy<code>action is not routable so we have to use an event instead. The event name will be</code>destroy<code>and it will
be triggered on</code>click<code>on the link, therefore we have</code>data-event-click=&ldquo;destroy&rdquo;`.</p>

<p>If you navigate to <a href="http://localhost:3000">http://localhost:3000</a> you should see the posts list.</p>

<p>Let&rsquo;s add our <strong>show</strong> action to the posts controller.</p>

<p>``` coffeescript app/assets/batman/controllers/posts_controller.js.coffee
&hellip;</p>

<p>show: (params) &ndash;>
  BatmanJsBlog.Post.find params.id, @errorHandler (post) =></p>

<pre><code>@set('post', post)
</code></pre>

<p>&hellip;
```</p>

<p>Again <code>BatmanJsBlog.Post.find params.id</code> uses the given id in the request parameters to query our API. The result is stored in a <code>post</code> variable and set as a controller
attribute as usual with <code>@set</code>.</p>

<p>Now we can write the <strong>show</strong> view.</p>

<p>``` html app/assets/batman/html/posts/show.html</p>

<h1 data-bind="post.title"></h1>




<p data-bind="post.content"></p>


<p><a data-route="routes.posts[post].edit">Edit</a> |
<a data-event-click="destroy">Destroy</a></p>

<ul>
  <li data-foreach-comment="post.comments">
    <p data-bind="comment.content"></p>
  </li>
</ul>


<p>```</p>

<p>Everything should look familiar now. We are using multiple data bindings to display our post&rsquo;s attributes. <code>routes.posts[post].edit</code> is used to route to the <strong>edit</strong> action
of a particular post.<br/>
Here we can also display the comments as they are returned in the JSON too: remember, earlier in this tutorial we included them in the API on the posts' <strong>show</strong> action with
<code>include: :comments</code>.</p>

<p>Go back to your application and click on one post: you should see the post&rsquo;s show view.</p>

<p>Now that we have seen the <code>destroy</code> event twice, we can handle it in the controller.</p>

<p>``` coffeescript app/assets/batman/controllers/posts_controller.js.coffee
&hellip;</p>

<p>destroy: (node, event, context) &ndash;>
  post = if context.get(&lsquo;post&rsquo;) then context.get(&lsquo;post&rsquo;) else @post
  post.destroy (err) =></p>

<pre><code>if err
  throw err unless err instanceof Batman.ErrorsSet
else
  @redirect '/posts'
</code></pre>

<p>&hellip;
```</p>

<p>The first line instantiates our post.<br/>
As this is an event and not a route we have 3 arguments: <code>node, event, context</code>.<br/>
<code>node</code> represents the html node.<br/>
<code>event</code> represents the event that happenned.<br/>
<code>context</code> can help you access objects defined within a certain scope: here our node.</p>

<p>We linked to the <strong>destroy</strong> event at 2 different places: in the show where there is only one post defined (<code>@post</code>) and in the index where we use a loop to display multiple posts.
Depending which event was triggered, we have to fetch our post differently.<br/>
If <code>context.get('post')</code> exists then it means we are on the index view and we clicked &ldquo;destroy&rdquo; for one of our posts. This post is therefore available using context like this.<br/>
If it doesn&rsquo;t exist, then we are on the show view and <code>@post</code> is defined because it was defined in the <strong>show</strong> action with <code>@set('post', post)</code>.</p>

<p>Then, if everything goes well, we redirect to the <strong>index</strong> view in both cases.</p>

<p>Go ahead and try out these new &ldquo;destroy&rdquo; links: on the index and on the show views.</p>

<p>Now we should add some links on our layout to better the navigation.</p>

<p>``` html app/views/layouts/batman.html.erb
&lt;!DOCTYPE html>
<html>
<head>
  <title>Batman Js Blog</title>
  &lt;%= stylesheet_link_tag    &ldquo;application&rdquo;, :media => &ldquo;all&rdquo; %>
  &lt;%= javascript_include_tag &ldquo;batman_js_blog&rdquo; %>
  &lt;%= csrf_meta_tags %>
</head>
<body></p>

<p><a data-route="routes.posts">Posts</a> |
<a data-route="routes.posts.new">New Post</a></p>

<div data-yield="main"></div>




<script type="text/javascript">
  BatmanJsBlog.run();
</script>


<p></body>
</html>
```</p>

<p>We are adding 2 links under the <code>body</code>.<br/>
The first one routes to the posts list: the <strong>index</strong> action of our <strong>posts controller</strong>.<br/>
The second one routes to the <strong>new</strong> action of our <strong>posts controller</strong> that we are now going to write.</p>

<p>The <strong>new</strong> action is pretty much straightforward too.</p>

<p>``` coffeescript app/assets/batman/controllers/posts_controller.js.coffee
&hellip;</p>

<p>new: (params) &ndash;>
  @set(&lsquo;post&rsquo;, new BatmanJsBlog.Post)</p>

<p>&hellip;
```</p>

<p>We just create a new post, not saved yet.</p>

<p>Let&rsquo;s create a <strong>form</strong> on the new view now.</p>

<p>``` html app/assets/batman/html/posts/new.html
<form data-formfor-post="post" data-event-submit="create">
  <div></p>

<pre><code>&lt;label&gt;Title:&lt;/label&gt;
&lt;input data-bind="post.title" /&gt;
</code></pre>

<p>  </div></p>

<p>  <div></p>

<pre><code>&lt;label&gt;Content:&lt;/label&gt;
&lt;textarea data-bind="post.content"&gt;&lt;/textarea&gt;
</code></pre>

<p>  </div></p>

<p>  <input name="commit" type="submit" value="Submit">
</form>
```</p>

<p>As with <code>data-foreach</code>, <code>data-formfor</code> uses an existing variable and sets another one to be used within the context, both named &ldquo;post&rdquo;.<br/>
The form will just trigger an event, here the event is <strong>create</strong>, which corresponds to our <strong>create</strong> action (event) not yet defined.<br/>
We don&rsquo;t need any argument for this action.</p>

<p>``` coffeescript app/assets/batman/controllers/posts_controller.js.coffee
&hellip;</p>

<p>create: &ndash;>
  @post.save (err, post) =></p>

<pre><code>if err
  throw err unless err instanceof Batman.ErrorsSet
else
  @redirect post
</code></pre>

<p>&hellip;
```</p>

<p><code>@post</code> represents the post we created earlier in the <strong>new</strong> action.<br/>
We can save the post and redirect to the corresponding <strong>show</strong> action.</p>

<p>Now, go back to your browser and try creating a new post.</p>

<p>The <strong>edit</strong> action now is going to look quite like the <strong>show</strong> action because it only fetches a post with its id.</p>

<p>``` coffeescript app/assets/batman/controllers/posts_controller.js.coffee
&hellip;</p>

<p>show: (params) &ndash;>
  BatmanJsBlog.Post.find params.id, @errorHandler (post) =></p>

<pre><code>@set('post', post)
</code></pre>

<p>edit: (params) &ndash;>
  BatmanJsBlog.Post.find params.id, @errorHandler (post) =></p>

<pre><code>@set('post', post)
</code></pre>

<p>&hellip;
```</p>

<p>Let&rsquo;s refactor and write a <code>fetchPost</code> method.</p>

<p>``` coffeescript app/assets/batman/controllers/posts_controller.js.coffee
class BatmanJsBlog.PostsController extends BatmanJsBlog.ApplicationController
  routingKey: &lsquo;posts&rsquo;</p>

<p>  @beforeAction &lsquo;fetchPost&rsquo;, only: [&lsquo;show&rsquo;, &lsquo;edit&rsquo;]</p>

<p>  &hellip;</p>

<p>  show: (params) &ndash;></p>

<p>  edit: (params) &ndash;></p>

<p>  &hellip;</p>

<p>  fetchPost: (params) &ndash;></p>

<pre><code>BatmanJsBlog.Post.find params.id, @errorHandler (post) =&gt;
  @set('post', post)
</code></pre>

<p>```</p>

<p>Here, the <code>@beforeAction</code> works exactly like Rails' one does. It executes <code>fetchPost</code> before the <strong>show</strong> and <strong>edit</strong> actions.</p>

<p>Again the <strong>edit</strong> view looks like the <strong>new</strong> view.</p>

<p>``` html app/assets/batman/html/posts/edit.html
<form data-formfor-post="post" data-event-submit="update">
  <div></p>

<pre><code>&lt;label&gt;Title:&lt;/label&gt;
&lt;input data-bind="post.title" /&gt;
</code></pre>

<p>  </div></p>

<p>  <div></p>

<pre><code>&lt;label&gt;Content:&lt;/label&gt;
&lt;textarea data-bind="post.content"&gt;&lt;/textarea&gt;
</code></pre>

<p>  </div></p>

<p>  <input name="commit" type="submit" value="Submit">
</form>
```</p>

<p>The only difference is the event triggered: here it is <code>update</code>.</p>

<p>Let&rsquo;s refactor both our <strong>edit</strong> and <strong>new</strong> views using a partial.</p>

<p><code>html app/assets/batman/html/posts/edit.html
&lt;form data-formfor-post="post" data-event-submit="update"&gt;
  &lt;div data-partial="posts/_form"&gt;&lt;/div&gt;
&lt;/form&gt;
</code></p>

<p><code>html app/assets/batman/html/posts/new.html
&lt;form data-formfor-post="post" data-event-submit="create"&gt;
  &lt;div data-partial="posts/_form"&gt;&lt;/div&gt;
&lt;/form&gt;
</code></p>

<p>I think you get it here without explanations&hellip; Just create the <strong>_form</strong> partial.</p>

<p>``` html app/assets/batman/html/posts/_form.html</p>

<div>
  <label>Title:</label>
  <input data-bind="post.title" />
</div>




<div>
  <label>Content:</label>
  <textarea data-bind="post.content"></textarea>
</div>


<p><input name="commit" type="submit" value="Submit">
```</p>

<p>Finally, the <strong>update</strong> action looks exactly like the <strong>create</strong> action.</p>

<p>``` coffeescript app/assets/batman/controllers/posts_controller.js.coffee
&hellip;</p>

<p>update: &ndash;>
  @post.save (err, post) =></p>

<pre><code>if err
  throw err unless err instanceof Batman.ErrorsSet
else
  @redirect post
</code></pre>

<p>&hellip;
```</p>

<p>You should be able to edit your posts thanks to the previously created link in the show view now.</p>

<h3>The comments</h3>

<p>Let&rsquo;s add a link to destroy our comments on the posts' show view.</p>

<p>``` html app/assets/batman/html/posts/show.html
&hellip;</p>

<ul>
  <li data-foreach-comment="post.comments">
    <p data-bind="comment.content"></p>
    <a data-event-click="destroyComment">Destroy</a>
  </li>
</ul>


<p>```</p>

<p>The event triggered by the link will be <code>destroyComment</code> as we are still in the posts controller and the <code>destroy</code> action (event) is already used to destroy a post. It would
probably be messy to use the same event.</p>

<p>Let&rsquo;s write this new event.</p>

<p>``` coffeescript app/assets/batman/controllers/posts_controller.js.coffee
destroyComment: (node, event, context) &ndash;>
  comment = context.get(&lsquo;comment&rsquo;)
  comment.destroy (err) =></p>

<pre><code>if err
  throw err unless err instanceof Batman.ErrorsSet
else
  @post.get('comments').remove comment
  @redirect '/posts/' + @post.get('id')
</code></pre>

<p>```</p>

<p>Here we get the <code>comment</code> using the context.<br/>
If everything goes well, we also remove the comment from the post&rsquo;s comments list so that the comment disappears (on the html page).<br/>
And then we redirect on the post&rsquo;s <strong>show</strong> view i.e. where we were when clicking the destroy link.</p>

<p>Go ahead and try it.</p>

<p>Now let&rsquo;s add the possibility to create a new comment on every post show view.</p>

<p>``` html app/assets/batman/html/posts/show.html
&hellip;</p>

<p><form data-formfor-comment="comment" data-event-submit="createComment">
  <div></p>

<pre><code>&lt;label&gt;Content:&lt;/label&gt;
&lt;textarea data-bind="comment.content"&gt;&lt;/textarea&gt;
</code></pre>

<p>  </div></p>

<p>  <input name="commit" type="submit" value="Submit">
</form>
```</p>

<p>Then just get the controller right.</p>

<p>``` coffeescript app/assets/batman/controllers/posts_controller.js.coffee
&hellip;</p>

<p>show: (params) &ndash;>
  # Initializing a new comment with the post_id given in params to display
  # a corresponding form
  @set(&lsquo;comment&rsquo;, new BatmanJsBlog.Comment(post_id: params.id))</p>

<p>&hellip;</p>

<p>createComment: &ndash;>
  @comment.save =></p>

<pre><code># If everything goes well, we add the new comment to the current post's comments list so that it appears on the (html) page
@post.get('comments').add @comment
@redirect '/posts/' + @post.get('id')
</code></pre>

<p>&hellip;
```</p>

<p>You should now be able to create new comments. ; )</p>

<h3>Errors handling</h3>

<p>We can now add some information when validations fail for posts.</p>

<p>You can add this at the top of the <strong>new</strong> and <strong>edit</strong> views.</p>

<p>``` html</p>

<div data-partial="posts/_errors"></div>


<p>```</p>

<p>And create the corresponding partial.</p>

<p>``` html app/assets/batman/html/posts/_errors.html</p>

<div data-showif="post.errors.length">
  <p>
    <span data-bind="'error' | pluralize post.errors.length"></span>
    prevented this post from being created:
  </p>
  <ul>
    <li data-bind="error.message" data-foreach-error="post.errors"></li>
  </ul>
</div>


<p>```</p>

<p>The first line means the <code>div</code> is displayed only if there are errors included within the post.<br/>
Take a look at the <code>li</code> tag, and see how we took advantage of <code>data-bind</code> combined with <code>data-foreach</code> here.</p>

<p>If validations fail, Rails sends back the object with errors included in the JSON. But we could also take advantages of Batman.js capabilities and add some validations on
the client side.</p>

<p>``` coffeescript app/assets/batman/models/post.js.coffee
&hellip;</p>

<p>@validate &ldquo;title&rdquo;,   presence: true
@validate &ldquo;content&rdquo;, presence: true
```</p>

<p>Now Batman.js knows how to validate our post objects and does not need to send a request to Rails and wait for a reply before showing the errors: it can display them right away.</p>

<p>You can try creating an empty post and see what happens. : )</p>

<p>As a recap for this last part, your <strong>posts_controller</strong> should look like this:</p>

<p>``` coffeescript app/assets/batman/controllers/posts_controller.js.coffee
class BatmanJsBlog.PostsController extends BatmanJsBlog.ApplicationController
  routingKey: &lsquo;posts&rsquo;</p>

<p>  @beforeAction &lsquo;fetchPost&rsquo;, only: [&lsquo;show&rsquo;, &lsquo;edit&rsquo;]</p>

<p>  index: (params) &ndash;></p>

<pre><code>@set('posts', BatmanJsBlog.Post.get('all'))
</code></pre>

<p>  show: (params) &ndash;></p>

<pre><code>@set('comment', new BatmanJsBlog.Comment(post_id: params.id))
</code></pre>

<p>  edit: (params) &ndash;></p>

<p>  new: (params) &ndash;></p>

<pre><code>@set('post', new BatmanJsBlog.Post)
</code></pre>

<p>  create: &ndash;></p>

<pre><code>@post.save (err, post) =&gt;
  if err
    throw err unless err instanceof Batman.ErrorsSet
  else
    @redirect post
</code></pre>

<p>  update: &ndash;></p>

<pre><code>@post.save (err, post) =&gt;
  if err
    throw err unless err instanceof Batman.ErrorsSet
  else
    @redirect post
</code></pre>

<p>  destroy: (node, event, context) &ndash;></p>

<pre><code>post = if context.get('post') then context.get('post') else @post
post.destroy (err) =&gt;
  if err
    throw err unless err instanceof Batman.ErrorsSet
  else
    @redirect '/posts'
</code></pre>

<p>  createComment: &ndash;></p>

<pre><code>@comment.save =&gt;
  @post.get('comments').add @comment
  @redirect '/posts/' + @post.get('id')
</code></pre>

<p>  destroyComment: (node, event, context) &ndash;></p>

<pre><code>comment = context.get('comment')
comment.destroy (err) =&gt;
  if err
    throw err unless err instanceof Batman.ErrorsSet
  else
    @post.get('comments').remove comment
    @redirect '/posts/' + @post.get('id')
</code></pre>

<p>  fetchPost: (params) &ndash;></p>

<pre><code>BatmanJsBlog.Post.find params.id, @errorHandler (post) =&gt;
  @set('post', post)
</code></pre>

<p>```</p>

<p>Hope it all helps, talk to you later! ; )</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Differences between has_one and belongs_to in Ruby on Rails]]></title>
    <link href="http://requiremind.com/differences-between-has-one-and-belongs-to-in-ruby-on-rails"/>
    <updated>2013-06-29T16:42:00+02:00</updated>
    <id>http://requiremind.com/differences-between-has-one-and-belongs-to-in-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>When getting started with Ruby on Rails, associations between models can become quite confusing especially when there&rsquo;s a thin line between two of them.</p>

<!-- more -->


<p>At first we&rsquo;re tempted to use the one that makes more sense when thinking about it&hellip; For instance we can say that a <em>page</em> belongs to a <em>book</em>, but we could say that a
<em>page</em> has one <em>book</em> too. The two of them establish a one-to-one association between both models.</p>

<p>But the question we need to ask ourselves here is: <strong>in which model do I want the foreign key to be?</strong> In fact, this is the slight difference between <code>has_one</code> and
<code>belongs_to</code> in Ruby on Rails.</p>

<p><strong><code>belongs_to</code> will place the foreign key in the declaring model whereas <code>has_one</code> will place it in the other model.</strong></p>

<p>Let&rsquo;s see some examples, first using <code>belongs_to</code>.</p>

<p>``` ruby
class Book &lt; ActiveRecord::Base
end</p>

<p>class Page &lt; ActiveRecord::Base
  belongs_to :book
end
```</p>

<p>This will use a <strong>book_id</strong> field in the <em>pages</em> table (note: of course you need to add that field with a migration).
It also adds 4 methods in the Page class: <code>book</code>, <code>book=</code>, <code>build_book</code>, <code>create_book</code>.</p>

<p>``` ruby
page = Page.create!
=> #<Page id: 1, book_id: nil></p>

<p>book = Book.create!
=> #<Book id: 1></p>

<p>page.book = book
=> #<Book id: 1></p>

<p>page
=> #<Page id: 1, book_id: 1></p>

<p>other_book = page.create_book!
=> #<Book id: 2></p>

<p>page
=> #<Page id: 1, book_id: 2></p>

<p>page.book
=> #<Book id: 2>
```</p>

<p>To make this a one-to-many association just declare the other side of it.</p>

<p>``` ruby
class Book &lt; ActiveRecord::Base
  has_many :pages
end</p>

<p>class Page &lt; ActiveRecord::Base
  belongs_to :book
end
```</p>

<p>Now a book has many pages (and each page still belongs to a book) and you can use the usual methods on the book:
<code>pages</code>, <code>pages&lt;&lt;</code>, <code>pages.find</code>, <code>pages.build</code>, <code>pages.create</code> and many more.</p>

<p>If we use a <code>has_one</code> association, here what happens:</p>

<p>``` ruby
class Book &lt; ActiveRecord::Base
end</p>

<p>class Page &lt; ActiveRecord::Base
  has_one :book
end
```</p>

<p>Here are some examples:</p>

<p>``` ruby
page = Page.create!
=> #<Page id: 1></p>

<p>book = Book.create!
=> #<Book id: 1, page_id: nil></p>

<p>page.book = book
=> #<Book id: 1, page_id: 1></p>

<p>other_book = page.create_book!
=> #<Book id: 2, page_id: 1>
```</p>

<p>You will probably want to set the other side of the association at some point.</p>

<p>``` ruby
class Book &lt; ActiveRecord::Base
  belongs_to :page
end</p>

<p>class Page &lt; ActiveRecord::Base
  has_one :book
end
```</p>

<p>But that way a book can only have one page&hellip;</p>

<p>To sum things up: use <code>belongs_to</code> when you want the foreign key in the declaring model, use <code>has_one</code> if you want it on the other model.</p>

<p>But anyway, you will rarely see a <code>belongs_to</code> or a <code>has_one</code> used alone. Most of the time it will be <code>has_many</code> with <code>belongs_to</code> for a one-to-many
association and <code>has_one</code> with <code>belongs_to</code> for a one-to-one association.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Riding Rails 4 along with Mongoid and Ruby 2.0]]></title>
    <link href="http://requiremind.com/riding-rails-4-along-with-mongoid-and-ruby-2-dot-0"/>
    <updated>2013-05-26T01:38:00+02:00</updated>
    <id>http://requiremind.com/riding-rails-4-along-with-mongoid-and-ruby-2-dot-0</id>
    <content type="html"><![CDATA[<p>You&rsquo;re not without knowing that Rails 4 is about to kick in in a few days (weeks?), are you? In a recent hobby project of mine: <a href="https://6lock.com">6LOCK</a>,
I tested out MongoDB, together with Mongoid (the ORM that comes in replacement of ActiveRecord for querying the MongoDB database) and other pretty cool stuff. As I had a great time using it
I wanted to give it a try using the all new and shiny Rails 4 and Ruby 2.</p>

<!-- more -->


<p>If you have a basic understanding of how the framework works, you have already been following some sort of &ldquo;Getting Started with Ruby on Rails&rdquo; tutorial (plenty of them out there)
and now you want to try MongoDB and see how it feels, this tutorial is made for you.</p>

<p>Note: I am not going to list the new features of Rails 4, if you want to know more, check out this great post:
<a href="http://net.tutsplus.com/tutorials/ruby/digging-into-rails-4/">digging-into-rails-4</a></p>

<p>All the resources and documentation stuff are at the end of the post, be sure to check them out, you&rsquo;ll probably learn very interesting stuff and subtleties.</p>

<p>I ran into some compatibility issues when writing this tutorial (nothing to be worried about) but gems versions may now have evolved.<br/>
FYI: Ubuntu 12.10, rails 4.0.0.rc1, mongoid (github master, something between 3.1.4 and ?) and bson_ext 1.8.6</p>

<p>EDIT: as stated by Shunwen in the comments below, bson_ext seems to no longer be required as of mongoid version 3. Check it out here: <a href="http://mongoid.org/en/mongoid/docs/upgrading.html">http://mongoid.org/en/mongoid/docs/upgrading.html</a>.</p>

<p>Application github repo: <a href="https://github.com/Raindal/rails4_mongoid">https://github.com/Raindal/rails4_mongoid</a></p>

<p>Finally, I am not going to give you any advice on why you should or should not use MongoDB, lots of topics are listing pros and cons compared to traditional relational databases such as
MySQL. To give you some leads you could dig into, MongoDB brings to the table things like dynamic fields, embedding, map/reduce, indexing and so on.</p>

<p>But enough talking, let&rsquo;s dive in!</p>

<h3>Install MongoDB</h3>

<blockquote><p><a href="http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/">Install MongoDB on Ubuntu</a></p></blockquote>

<p>First you&rsquo;ll need to import the 10gen public GPG key (MongoDB is mainly maintained by 10gen), which is used to ensure package consistency and authenticity</p>

<pre><code>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv 7F0CEB10
</code></pre>

<p>Create a /etc/apt/sources.list.d/10gen.list file using the following command</p>

<pre><code>echo 'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen' | sudo tee /etc/apt/sources.list.d/10gen.list
</code></pre>

<p>Now you can update your repository</p>

<pre><code>sudo apt-get update
</code></pre>

<p>And then install the package</p>

<pre><code>sudo apt-get install mongodb-10gen
</code></pre>

<p>To check that it works, just issue a <code>mongo</code> in your shell and you should see something like</p>

<pre><code>MongoDB shell version: x.x.x
connecting to: test
&gt;
</code></pre>

<h3>Set up RVM</h3>

<blockquote><p><a href="http://net.tutsplus.com/tutorials/why-you-should-use-rvm/">Why you should use RVM</a></p></blockquote>

<p>Now we are going to set up RVM to use Ruby 2.0.0. We only have to install the Ruby version we want and use it.</p>

<pre><code>rvm install 2.0.0
rvm use 2.0.0
</code></pre>

<p>And finally we are going to create a gemset for our application, it will contain all the gems we need</p>

<pre><code>rvm gemset create rails4_mongoid
</code></pre>

<h3>Set up the application</h3>

<p>First we need to install the Rails 4 gem.</p>

<pre><code>gem install rails --version 4.0.0.rc1 --no-ri --no-rdoc
</code></pre>

<p>Now we can create the application and cd inside</p>

<pre><code>rails new rails4_mongoid
cd rails4_mongoid/
</code></pre>

<p>For convinience, we are creating a .rvmrc file at the root of our application. The file will tell RVM to use the right version of Ruby with the right gemset when we cd inside the directory.<br/>
Just use your favorite text editor</p>

<pre><code>nano .rvmrc
</code></pre>

<p>And paste this inside</p>

<p><code>ruby .rvmrc
rvm use 2.0.0@rails4_mongoid --create
</code></p>

<p>This basically tells RVM to use Ruby 2.0.0 with the gemset rails4_mongoid and that it should create the gemset if it doesn&rsquo;t already exist.</p>

<p>To make sure everything works as expected, you can go back and then cd again in the directory.</p>

<pre><code>cd ..
cd rails4_mongoid
</code></pre>

<p>You should see something like this</p>

<pre><code>Using /home/neil/.rvm/gems/ruby-2.0.0-p0 with gemset rails4_mongoid
</code></pre>

<p>Now, we have to edit the Gemfile to install the gems we want.<br/>
First, remove sqlite: delete these lines</p>

<p>``` ruby Gemfile</p>

<h1>Use sqlite3 as the database for Active Record</h1>

<p>gem &lsquo;sqlite3&rsquo;
```
Now we can add mongoid and bson_ext</p>

<p><code>ruby Gemfile
gem 'mongoid', github: 'mongoid/mongoid'
gem 'bson_ext', '~&gt; 1.8.6'
</code></p>

<p>At the time I&rsquo;m writing these lines, <a href="http://rubygems.org/gems/mongoid/versions/3.1.4">mongoid 3.1.4 relies on ActiveModel 3.2</a> but we are using ActiveModel 4.0.0-rc1, so we need to use directly
the github repo that supports it.<br/>
bson_ext is a C extension which basically makes things faster with MongoDB.</p>

<p>Now, just run a</p>

<pre><code>bundle update
</code></pre>

<p>If you run into errors of some kind (mine was related to bson_ext), try to update your gem version with</p>

<pre><code>rvm rubygems latest --verify-downloads 1
</code></pre>

<p>And <code>bundle update</code> again.</p>

<h3>Configure Mongoid</h3>

<p>Still in the root of the application, run the following command</p>

<pre><code>rails g mongoid:config
</code></pre>

<p>This will generate a <strong>mongoid.yml</strong> file under <strong>config/</strong>.<br/>
We can edit the file to suit our needs.</p>

<p>Find the line that says <code># consistency: :eventual</code> and change it for</p>

<p><code>yaml config/mongoid.yml
consistency: :strong
</code></p>

<p><code>:eventual</code> will send reads to secondaries, <code>:strong</code> sends everything to master.</p>

<p>As we are not using ActiveRecord, we need to get rid of it.<br/>
First in <strong>config/application.rb</strong> comment out the line</p>

<p>``` ruby config/application.rb</p>

<h1>require &lsquo;rails/all&rsquo;</h1>

<p>```</p>

<p>And add these lines right underneath the first one</p>

<p>``` ruby config/application.rb
require &ldquo;action_controller/railtie&rdquo;
require &ldquo;action_mailer/railtie&rdquo;</p>

<h1>require &ldquo;active_resource/railtie&rdquo;</h1>

<p>require &ldquo;sprockets/railtie&rdquo;
```</p>

<p>The 3rd line is commented out because normally you would need it but Rails 4 has extracted the ActiveResource gem and now you need to specify its name in the Gemfile if you want to use it. But here we won&rsquo;t
use it.</p>

<p>There are some more ActiveRecord settings we have to get rid of out there.<br/>
In <strong>config/environments/development.rb</strong>, comment out this line</p>

<p>``` ruby config/environments/development.rb</p>

<h1>config.active_record.migration_error = :page_load</h1>

<p>```</p>

<p>To check that everything is working like a charm, run a <code>rails s</code> and then go check that the application is running on <a href="http://localhost:3000">http://localhost:3000</a>.</p>

<p>Now you should see the usual <strong>Welcome aboard</strong> message.</p>

<h3>Now we&rsquo;re talking!</h3>

<p>Let&rsquo;s write some code, finally! But first we will have to generate our first model. For that we are going to use the builtin <em>scaffold</em> command in order to generate our model, controller,
views and everything else at the same time.</p>

<blockquote><p>In a real project, unless you&rsquo;re sure you&rsquo;re going to use all the generated files, I personnaly don&rsquo;t recommend using the scaffold command. You could quickly end up with a messy application.
I would rather recommend using each command one by one: <code>rails g model xxx</code>, <code>rails g controller xxx</code> etc.</p></blockquote>

<p>For this example I&rsquo;ll be using the usual Post > Comment stuff which is actually a perfect example for demonstrating the embedding capabilities of MongoDB.</p>

<p>Let&rsquo;s generate our Post first, it will have 3 fields: a <strong>title</strong>, a <strong>body</strong> and it can be <strong>starred</strong>.</p>

<pre><code>rails g scaffold post title:string body:string starred:boolean
</code></pre>

<blockquote><p><a href="http://mongoid.org/en/mongoid/docs/documents.html#fields">Mongoid document field types</a></p></blockquote>

<p>This generated all the files we wanted.<br/>
Let&rsquo;s first edit the model to add the <strong>created_at</strong> and <strong>updated_at</strong> fields that are not present by default.<br/>
We can also add an index on the <strong>starred</strong> field because we will often be querying on it with a <code>where</code> clause for example (not in this application actually).</p>

<p>Your Post model should look like so</p>

<p>``` ruby app/models/post.rb
class Post
  include Mongoid::Document
  include Mongoid::Timestamps</p>

<p>  field :title, type: String
  field :body, type: String
  field :starred, type: Boolean</p>

<p>  index({ starred: 1 })
end
```</p>

<p>Now we have a command to enforce indexes on the database</p>

<pre><code>rake db:mongoid:create_indexes
</code></pre>

<p>This will set an index on the <em>starred</em> field of the <em>post</em> collection.</p>

<blockquote><p>Quick tip: use <code>rake -T</code> to see a list a available tasks</p>

<p>Wait&hellip; we didn&rsquo;t create the database, did we? No we didn&rsquo;t, the database is automatically created.</p></blockquote>

<p>For some reason, Rails 4 uses the <code>update()</code> method by default to update an object in the corresponding controller action which does not behave as one could expect (and basically does not update
the document). This may be due to mongoid&hellip; Anyway, let&rsquo;s use <code>update_attributes()</code> instead.</p>

<p>In the recently created controller, change the <em>update</em> action to look like this one</p>

<p>``` ruby app/controllers/posts_controller.rb</p>

<h1>PATCH/PUT /posts/1</h1>

<h1>PATCH/PUT /posts/1.json</h1>

<p>def update
  respond_to do |format|</p>

<pre><code>if @post.update_attributes(post_params)
  format.html { redirect_to @post, notice: 'Post was successfully updated.' }
  format.json { head :no_content }
else
  format.html { render action: 'edit' }
  format.json { render json: @post.errors, status: :unprocessable_entity }
end
</code></pre>

<p>  end
end
```</p>

<p>We actually do not need all the json stuff because we are not writing some sort of API but the <code>scaffold</code> command generates it for us.</p>

<p>Now if you navigate to <a href="http://localhost:3000/posts">http://localhost:3000/posts</a> you should be able to play with the posts. : )<br/>
Go ahead, create/update/destroy a few posts to see if everything is working as expected.</p>

<h2>Embedding documents</h2>

<blockquote><p>A collection can be compared to a table.<br/>
A document can be compared to a row.</p></blockquote>

<p>Here I&rsquo;ve decided to show you how to embed documents in each other because this is one of the features that you will probably wind up using the most.<br/>
In MongoDB you can associate two documents with &ldquo;foreign keys&rdquo; although the concept does not really exists. So you can still use the usual stuff: <code>has_many</code>, <code>belongs_to</code> and so on.<br/>
<strong>But</strong>, there is no <em>join</em> is MongoDB, loading one document and its associated document will therefore execute two queries.</p>

<p>However you can set another type of relation: you can embed one document into another. Loading the parent document will also load all the children documents at the same time.<br/>
<strong>But</strong>, it will always instanciate all of the objects retrieved even if you do not need the children, plus, each document has a size limit: 16MB, if you have too many child
documents, the parent document&rsquo;s size could exceed this limit.</p>

<blockquote><p>Foreign key = 2 queries<br/>
Embedding = loading many objects all the time + parent document size limited</p>

<p><a href="http://docs.mongodb.org/manual/reference/limits/">MongoDB limits</a></p></blockquote>

<p>We suppose that when we load a post, we also want all of its associated comments and that there will not be thousands of comments.<br/>
So embedding seems to be a good choice.</p>

<p>Here is a design example of a MongoDB database with users that have posts and posts that have comments.</p>

<p><strong>users collection</strong></p>

<pre><code>[
  {
    "_id": "5063114bd386d8fadbd6b004",
    "name": "John Snow"
  }
]
</code></pre>

<p><strong>posts collection</strong></p>

<pre><code>[
  {
    "_id": "6563521bd386d6dadbd6b002",
    "title": "Why King's Landing should belong to Daenerys",
    "user_id": "5063114bd386d8fadbd6b004",
    "comments": [
      {
        "_id": "4586521bd638d6dadbd7b003"
        "body": "I totally agree with you, great post!"
      },
      {
        "_id": "8526521bd654d6dadbd7b001"
        "body": "I'm so sad since Drogo died..."
      }
    ]
  }
]
</code></pre>

<p>This being said, let&rsquo;s get started, shall we?</p>

<pre><code>rails g scaffold comment body:string
</code></pre>

<p>Now that our Comment model is generated, we can edit it to reflect this</p>

<p>``` ruby app/models/comment.rb
class Comment
  include Mongoid::Document
  include Mongoid::Timestamps</p>

<p>  embedded_in :post, inverse_of: :comments</p>

<p>  field :body, type: String
end
```</p>

<p>This just tells MongoDB that comments are to be embedded in the corresponding post.<br/>
The <code>inverse_of</code> option is required in order to tell Mongoid what the comment should be embedded through.</p>

<p>We can edit the Post model to reflect that association and add the <code>embeds_many :comments</code> (line 5)</p>

<p>``` ruby app/models/post.rb
class Post
  include Mongoid::Document
  include Mongoid::Timestamps</p>

<p>  embeds_many :comments</p>

<p>  field :title, type: String
  field :body, type: String
  field :starred, type: Boolean</p>

<p>  index({ starred: 1 })
end
```</p>

<p>Now we need to edit the <strong>routes</strong> file to make posts and comments nested resources.</p>

<p><code>ruby config/routes.rb
resources :posts do
  resources :comments
end
</code></p>

<p>This creates urls like <em>/posts/:post_id/comments</em>.</p>

<p>Now we have to change our <strong>comments_controller.rb</strong> and all our comments&rsquo;s views to reflect these nested resources: any comment we will be using now depends on a post.<br/>
Note: this part is not related to MongoDB or Mongoid. We would have gone through the same steps anyway with nested resources.</p>

<blockquote><p><a href="http://guides.rubyonrails.org/routing.html#nested-resources">Nested resources</a></p></blockquote>

<p>``` ruby app/controllers/comments_controller.rb
class CommentsController &lt; ApplicationController
  before_action :load_post
  before_action :set_comment, only: [:show, :edit, :update, :destroy]</p>

<p>  # GET /comments
  # GET /comments.json
  def index</p>

<pre><code>@comments = @post.comments
</code></pre>

<p>  end</p>

<p>  # GET /comments/1
  # GET /comments/1.json
  def show
  end</p>

<p>  # GET /comments/new
  def new</p>

<pre><code>@comment = @post.comments.build
</code></pre>

<p>  end</p>

<p>  # GET /comments/1/edit
  def edit
  end</p>

<p>  # POST /comments
  # POST /comments.json
  def create</p>

<pre><code>@comment = @post.comments.build(comment_params)

respond_to do |format|
  if @comment.save
    format.html { redirect_to [@post, @comment], notice: 'Comment was successfully created.' }
    format.json { render action: 'show', status: :created, location: @comment }
  else
    format.html { render action: 'new' }
    format.json { render json: @comment.errors, status: :unprocessable_entity }
  end
end
</code></pre>

<p>  end</p>

<p>  # PATCH/PUT /comments/1
  # PATCH/PUT /comments/1.json
  def update</p>

<pre><code>respond_to do |format|
  if @comment.update_attributes(comment_params)
    format.html { redirect_to [@post, @comment], notice: 'Comment was successfully updated.' }
    format.json { head :no_content }
  else
    format.html { render action: 'edit' }
    format.json { render json: @comment.errors, status: :unprocessable_entity }
  end
end
</code></pre>

<p>  end</p>

<p>  # DELETE /comments/1
  # DELETE /comments/1.json
  def destroy</p>

<pre><code>@comment.destroy
respond_to do |format|
  format.html { redirect_to post_comments_url(@post) }
  format.json { head :no_content }
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code># Use callbacks to share common setup or constraints between actions.
def set_comment
  @comment = @post.comments.find(params[:id])
end

# Never trust parameters from the scary internet, only allow the white list through.
def comment_params
  params.require(:comment).permit(:body)
end

def load_post
  @post = Post.find(params[:post_id])
end
</code></pre>

<p>end
```</p>

<p>What changed? Well, now we use the post passed in params to load, create, redirect comments.<br/>
See the <strong>load_post</strong> method, this is the root of everything else. We load a post using the :post_id that is sent and then we use this post everywhere.</p>

<blockquote><p>Quick tip: issue a <code>rake routes</code> to see the routes you can use in the application</p></blockquote>

<p>Now we need to change these routes in all the view files.
Here I&rsquo;ll show you only the lines that have changed.</p>

<p>``` erb app/views/comments/index.html.erb
<td>&lt;%= link_to &lsquo;Show&rsquo;, post_comment_path(@post, comment) %></td>
<td>&lt;%= link_to &lsquo;Edit&rsquo;, edit_post_comment_path(@post, comment) %></td>
<td>&lt;%= link_to &lsquo;Destroy&rsquo;, [@post, comment], method: :delete, data: { confirm: &lsquo;Are you sure?&rsquo; } %></td></p>

<p>&hellip;</p>

<p>&lt;%= link_to &lsquo;New Comment&rsquo;, new_post_comment_path(@post) %>
```</p>

<p>``` erb app/views/comments/_form.html.erb
&lt;%= form_for([@post, @comment]) do |f| %></p>

<p>&hellip;
```</p>

<p>``` erb app/views/comments/new.html.erb
&hellip;</p>

<p>&lt;%= link_to &lsquo;Back&rsquo;, post_comments_path(@post) %>
```</p>

<p>``` erb app/views/comments/show.html.erb
&hellip;</p>

<p>&lt;%= link_to &lsquo;Edit&rsquo;, edit_post_comment_path(@post, @comment) %> |
&lt;%= link_to &lsquo;Back&rsquo;, post_comments_path(@post) %>
```</p>

<p>``` erb app/views/comments/edit.html.erb
&hellip;</p>

<p>&lt;%= link_to &lsquo;Show&rsquo;, post_comment_path(@post, @comment) %> |
&lt;%= link_to &lsquo;Back&rsquo;, post_comments_path(@post) %>
```</p>

<p>Now return in your running application and create a new post.<br/>
Click on the <em>show</em> link to view the post you just created and just append <em>comments</em> to the url, like so: <a href="http://localhost:3000/posts/:post_id/comments.">http://localhost:3000/posts/:post_id/comments.</a></p>

<p>That&rsquo;s it! You should now be able to create comments and manage them with all the basic usual actions.</p>

<p>I hope this little introduction to Rails 4 with Mongoid helped you.</p>

<p>See you around!</p>

<h3>Resources</h3>

<ul>
<li><a href="http://net.tutsplus.com/tutorials/why-you-should-use-rvm/">Why you should use RVM</a></li>
<li><a href="http://net.tutsplus.com/tutorials/ruby/digging-into-rails-4/">Digging into Rails 4</a></li>
<li><a href="http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/">Install MongoDB on Ubuntu</a></li>
<li><a href="http://docs.mongodb.org/manual/reference/limits/">MongoDB limits</a></li>
<li><a href="http://mongoid.org/en/mongoid/docs/installation.html">Mongoid installation</a></li>
<li><a href="http://mongoid.org/en/mongoid/docs/documents.html#fields">Mongoid document field types</a></li>
<li><a href="http://mongoid.org/en/mongoid/docs/indexing.html">Indexing with Mongoid</a></li>
<li>If you don&rsquo;t know what are the new &ldquo;concerns&rdquo; folders in Rails 4: <a href="http://37signals.com/svn/posts/3372-put-chubby-models-on-a-diet-with-concerns">Put chubby models on a diet with concerns</a></li>
<li><a href="http://guides.rubyonrails.org/routing.html#nested-resources">Nested resources</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
