<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: learn-js | require 'mind']]></title>
  <link href="http://requiremind.com/categories/learn-js/atom.xml" rel="self"/>
  <link href="http://requiremind.com/"/>
  <updated>2015-01-26T21:48:32+01:00</updated>
  <id>http://requiremind.com/</id>
  <author>
    <name><![CDATA[requireMind]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Memoization, speed up your javascript performance]]></title>
    <link href="http://requiremind.com/memoization-speed-up-your-javascript-performance"/>
    <updated>2015-01-03T16:42:00+01:00</updated>
    <id>http://requiremind.com/memoization-speed-up-your-javascript-performance</id>
    <content type="html"><![CDATA[<p>Now that web apps and websites are getting bigger and bigger, performances have become a really important point to focus on. This article will introduce you the concept of <code>memoization</code> that will allow you to improve your functions performances through some cache mechanisms.</p>

<p>Fasten your seatbelt, I&rsquo;m starting the engine!</p>

<!-- more -->


<p><img class="center" src="/images/memoize/turing.jpg" title="&lsquo;turing&rsquo; &lsquo;turing&rsquo;" ></p>

<h3>Introduction</h3>

<p>Memoization is a simple mechanism that consist in caching the result of computed values. This allows the next function call, done with the same parameters, to hit the cache rather than re-computing this values.<br/>
The cache is indexed by the input arguments. If the arguments exist in the cache, then the cached value is returned. Otherwise, the function is executed and the newly computed value is added to the cache.</p>

<p>Let&rsquo;s see a basic example.</p>

<h3>Basic example</h3>

<p>``` js
var speedAlert = function(speed) {
  var limitation = 75;
  // Imagine the following line being an extra CPU intensive task
  return speed > limitation;
};</p>

<p>var radar = {
  // some properties and functions
  // &hellip;
};</p>

<p>radar.on(&lsquo;carDetected&rsquo;, function(car) {
  // The following function can then be called many times
  if(speedAlert(car.speed)) {</p>

<pre><code>radar.triggerFlash();
</code></pre>

<p>  }
});
```</p>

<p>As you can see the method <code>speedAlert</code> will be called many times. Imagine that inside this method there is a lot of computing going on (not just this basic operation :) ). So everytime we call it, we&rsquo;re going to use a lot of CPU time.</p>

<p>This is where <code>memoization</code> enter! Let&rsquo;s refactor the speedAlert method then.</p>

<p>``` js
var speedAlert = (function() {
  var cache      = {};
  var limitation = 75;</p>

<p>  function f(speed) {</p>

<pre><code>if(speed in cache) {
  console.log('hit cache');
  return cache[speed];
}

// Not in the cache, so compute the value and put it in the cache
cache[speed] = speed &gt; limitation;

return cache[speed];
</code></pre>

<p>  }</p>

<p>  return f;
})();</p>

<p>// Now let&rsquo;s call this method manually
speedAlert(90); // return true
speedAlert(70); // return false
speedAlert(90); // hit cache + return true
```</p>

<p>In the last line of the previous example, you can see that the computation hasn&rsquo;t been made. The code has fetch the value from the cache and returned it.
This is the process of memoization.
When this method is called, it will look inside his cache to see if it had already compute the value for this <code>speed</code> parameter and return it, or compute the value and push it into the cache.</p>

<p>So now, everytime this method is called with the same argument, it won&rsquo;t compute nothing and this is a large amount of time earned.</p>

<p>I want to point out that here the <code>limitation</code> variable (75) is stored inside the function. This is an important fact to notice. Indeed, if this value was global or outside this function, we wouldn&rsquo;t be able to memoize <code>speedAlert</code> because then, his result would be influenced by some external properties and won&rsquo;t depends only on his inputs.</p>

<p>Here is a quick example of what I just said:</p>

<p>``` js
var limitation = 75;</p>

<p>var speedAlert = // same definition as before except the limitation assignation has been moved outside</p>

<p>speedAlert(70); // return false
speedAlert(70); // hit cache + return false
limitation = 50;
speedAlert(70); // hit cache + return false /!\ it should be true
```</p>

<p>You see, the result is already cached for the input <code>70</code>, so it doesn&rsquo;t care about the limitation change as it will never trigger the computation again.
It&rsquo;s important to understand that only the functions from which the result is influenced by the input are able to be memoized. This mean functions that always respect this: <code>f(x) === f(x)</code></p>

<h3>Advanced usage</h3>

<p>We saw memoization on a basic example with only a single argument. But this process can also handles multiple arguments. Plus, we were doing the <code>memoization</code> implementation inside the function but we can write a memoize function that will take a function as a parameter. This way, we can apply memoization to any functions.</p>

<p>``` js
function memoize(fn, resolver) {
  var memoized = function() {</p>

<pre><code>resolver  = resolver || JSON.stringify;

var cache = memoized.cache;
var args  = Array.prototype.slice.call(arguments);
var key   = resolver.apply(this, args);

if(key in cache) {
  console.log('hit cache');
  return cache[key];
}

var result = fn.apply(this, arguments);
cache[key] = result;

return result;

// This could have been done with this one-liner too ;)
// return (key in cache) ? cache[key] : (cache[key] = fn.apply(this, arguments));
</code></pre>

<p>  };</p>

<p>  memoized.cache = {};</p>

<p>  return memoized;
}</p>

<p>```</p>

<p>Time for explanations, the <code>memoize</code> function takes two parameters, a function (the one we want to memoize) and an <em>optional</em> resolver.</p>

<p>Now that our <code>memoize</code> is more &lsquo;abstract&rsquo;, we can have multiple arguments passed to our function. So the <code>key</code> for the <code>cache</code> can&rsquo;t be as simple as the first argument anymore. That&rsquo;s why we&rsquo;re asking for a resolver. His goal is to take the <code>arguments</code> and compute a key for it.</p>

<p><em>Note: In the previous example, we&rsquo;re using <code>JSON.stringify</code> as a <code>resolver</code>, but this one is not a bullet-proof solution as it won&rsquo;t work with all cases, plus, keep in mind that <code>key in cache</code> syntax is definitely not optimzed but allows this example to stay clear and light.<br/>
That&rsquo;s why the cache management here is really basic. A way to start optimizing it could be by using a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">weak map</a> rather than an object (cool feature coming in ES6)</em></p>

<p>Time has come to play with it!</p>

<p>``` js</p>

<p>var speedAlert = memoize(function(speed) {
  var limitation = 75;
  // Imagine the following line being an extra CPU intensive task
  return speed > limitation;
});</p>

<p>speedAlert(50); // return false
speedAlert(50); // hit cache + return false
speedAlert(90); // return true
speedAlert(90); // hit cache + return true
```</p>

<p>So now, our <code>speedAlert</code> method is a normal function declaration and the memoize wrapper handles all the memoization process for us. That is pretty neat.</p>

<p>That&rsquo;s it for this article I hope you..</p>

<blockquote><p>Don&rsquo;t stop here! How could I see that it improve my performance.</p></blockquote>

<p>Ok ok, let&rsquo;s make a quick test with the well known <a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonnaci sequence</a>. This function is really adapted to this example as it has a lot of recursive calls and regularly compute the same values.
We&rsquo;re going to use some nice functions called <code>console.time</code> and <code>console.timeEnd</code> that give us the ability to easily track the time in our console.</p>

<p>``` js
function fibonacci(n) {
  return (n === 0 || n === 1) ? n : fibonacci(n &ndash; 1) + fibonacci(n &ndash; 2);
}</p>

<p>var fibMemoize = memoize(fibonacci);
var iterations = 35;</p>

<p>console.time(&lsquo;non-memoized&rsquo;);
console.log(fibMemoize(iterations));
console.timeEnd(&lsquo;non-memoized&rsquo;); // log 195.896ms</p>

<p>// Now this call is memoized, so it&rsquo;s just going to hit the cache
console.time(&lsquo;memoized&rsquo;);
console.log(fibMemoize(iterations));
console.timeEnd(&lsquo;memoized&rsquo;); // log 0.193ms
```</p>

<p>And you&rsquo;re going to see that, the more you increment the <code>iterations</code> variable, the more the utility of the <code>memoize</code> function is important! <em>(but don&rsquo;t push it too far, I&rsquo;ve managed to freeze Chrome with a 75 value..)</em></p>

<h4>Even better</h4>

<p>But we can do even better than this! <em>(thanks Samuel Rouse for pointing this out on the comments!)</em><br/>
The trick is simple.<br/>
Here, the fibonacci function is calling itself recursively. But it&rsquo;s calling recursively on a non-memoized function. The performances are really improved if the recursivity is based on a memoized function.<br/>
This is how we can do it:</p>

<p>``` js
var fibonacci = memoize(function(n) {
  return (n === 0 || n === 1) ? n : fibonacci(n &ndash; 1) + fibonacci(n &ndash; 2);
});</p>

<p>```</p>

<p>You can see that <code>fibonacci</code> is now a memoized function which implies that all recursive calls are memoized too. And this is a <strong>huge</strong> performance gain.<br/>
Indeed, when you call <code>fibonacci(35)</code> it will call <code>fibonacci(34) + fibonacci(33)</code>. Recursively, <code>fibonacci(34)</code> will call <code>fibonacci(33) + fibonacci(32)</code> and as you can see, <code>fibonacci(33)</code> has already been computed (thanks to the memoize), so we hit the cache.<br/>
So now, you can easily increase the iterations number! :D</p>

<hr />

<p>So, for all your CPU intensive tasks, think about implementing some memoize mechanism.<br/>
But don&rsquo;t forget some of the downsides.</p>

<p>You can&rsquo;t use it on a function that doesn&rsquo;t return the same result for the same input. It&rsquo;s not adapted to fast executing functions or not often called ones. Plus, the cache management have to be improved for heavy usages with some notion of retention and so on.</p>

<p>Don&rsquo;t hesitate to share your opinion in the comments.</p>

<p>If you want to discover more about Javascript, you can have a look to this <a href="/categories/learn-js">serie of articles</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Currying, spice up your javascript functions]]></title>
    <link href="http://requiremind.com/currying-spice-up-your-javascript-functions"/>
    <updated>2015-01-02T14:41:00+01:00</updated>
    <id>http://requiremind.com/currying-spice-up-your-javascript-functions</id>
    <content type="html"><![CDATA[<p>Currying is an interesting technique that will power up your functions usage. In this article we&rsquo;re going to explain it from basic example to some more advanced use cases and you&rsquo;ll see that knowing this pattern, will give you some extra power as a developer.</p>

<p>It&rsquo;s time to cook, let&rsquo;s spice it up!</p>

<!-- more -->


<p><img class="center" src="/images/currying/spices.png" title="&lsquo;spices&rsquo; &lsquo;spices&rsquo;" ></p>

<h3>Definition</h3>

<p>To begin, a definition won&rsquo;t hurt.</p>

<p>Currying is a process which allows you to bind some arguments to a function so that, by the next invocation, these values are already fixed. It&rsquo;s oftenly referred as &lsquo;partial functions&rsquo;. You can see it as a way to prefilled some of the arguments to obtain a more specific function.</p>

<p>But, enough talking it&rsquo;s time for a basic code example!</p>

<h3>Basic example</h3>

<p>``` js
var liker = function(type) {</p>

<pre><code>return function(name) {
    var result = 'I like this ' + type + ': ' + name;
    return result;
};
</code></pre>

<p>};</p>

<p>var bookLiker = liker(&lsquo;book&rsquo;);
bookLiker(&lsquo;Oro&rsquo;);  // I like this book: Oro
bookLiker(&lsquo;Wild: A journey from lost to found&rsquo;); // I like this book: Wild: A journey from lost to found</p>

<p>var tedLiker = liker(&lsquo;TED talk&rsquo;);
tedLiker(&lsquo;The art of misdirection&rsquo;); // I like this TED talk: The art of misdirection</p>

<p>```</p>

<p>Now it should be more clear for you. The <code>liker</code> is a <em>curried function</em>. As you can see, we use it to <em>prefill</em> the first argument before the final function is executed.
This allows us to create more specific likers function as <em>bookLiker</em> or <em>tedTalkLiker</em> in our case.</p>

<p>It was the most basic example to introduce you with this concept, so it&rsquo;s now time to move forward.</p>

<h3>Advanced usage</h3>

<p>We can write a curry helper function that is going to transform any &ldquo;<em>standard</em>&rdquo; function into a curried one.
We&rsquo;ll move from step to step on the implementation, so that you can absorb more easily the process.</p>

<p>So, let&rsquo;s start with the first one.</p>

<h4>1 &ndash; A naive implementation</h4>

<p>``` js
function naiveCurry(fn) {</p>

<pre><code>var args = Array.prototype.slice.call(arguments, 1);
return function() {
    return fn.apply(this, args.concat(
        Array.prototype.slice.call(arguments))
    );
}
</code></pre>

<p>}
```</p>

<p>Let&rsquo;s have a look.
First, it stores the arguments passed to our function in a <code>args</code> property. Except for the first argument (the function we want to curry).
It then returns a function. When you then call this function, the old arguments (stored in the <code>args</code> property) are concatenated with the new arguments received and applied to the curried function <code>fn</code>.</p>

<p><em>For those who didn&rsquo;t know, <code>arguments</code> is a specific word in Javascript and it corresponds to the arguments passed as parameters (even if they are not specified in the function signature). This <code>arguments</code> variable behaves like an <code>Array</code> but it&rsquo;s not from an <code>Array</code> type, that&rsquo;s why you&rsquo;re seeing those <code>Array.prototype</code> calls.</em></p>

<p>To illustrated it, a use case can be a <code>sendMessage</code> function:</p>

<p>``` js
var sendMessage = function(from, to, text) {</p>

<pre><code>return '@' + to + ': ' + text + ' - ' + from;
</code></pre>

<p>};</p>

<p>// return &ldquo;@Irene Adler: Stop boring me and think. It&rsquo;s the new sexy &ndash; Sherlock Holmes&rdquo;
sendMessage(&lsquo;Sherlock Holmes&rsquo;, &lsquo;Irene Adler&rsquo;, &lsquo;Stop boring me and think. It\&rsquo;s the new sexy.&rsquo;);
naiveCurry(sendMessage, &lsquo;SH&rsquo;)(&lsquo;IA&rsquo;, &lsquo;Stop boring me and think. It\&rsquo;s the new sexy.&rsquo;);
naiveCurry(sendMessage, &lsquo;SH&rsquo;, &lsquo;IA&rsquo;)(&lsquo;Stop boring me and think. It\&rsquo;s the new sexy.&rsquo;);</p>

<p>var sendMessageFromSherlock = naiveCurry(sendMessage, &lsquo;SH&rsquo;);
sendMessageFromSherlock(&lsquo;IA&rsquo;, &lsquo;Stop boring me and think. It\&rsquo;s the new sexy.&rsquo;);
```</p>

<p>Well that&rsquo;s fine, but as you can see the implementation is quite naive and can&rsquo;t resolve all the currying case, but we&rsquo;re getting closer to the final syntax.</p>

<h4>2 &ndash; A better implementation</h4>

<p>``` js
function curry(fn, length) {</p>

<pre><code>// Give us the function's arity (number of arguments)
length = length || fn.length;
return function () {
    var allArgumentsSpecified = (arguments.length &gt;= length);
    // We have all arguments, we can apply them to the function
    if(allArgumentsSpecified) {
        return fn.apply(this, arguments);
    }

    // We're missing some arguments, so we keep currying
    var partial = [fn].concat(Array.prototype.slice.call(arguments));
    return curry(naiveCurry.apply(this, partial), length - arguments.length);
};
</code></pre>

<p>}
```</p>

<p>And the magic is on! This curry implementation is now way more robust.</p>

<p>``` js
var sendMessageCurried = curry(sendMessage);</p>

<p>sendMessageCurried(&lsquo;Sherlock&rsquo;, &lsquo;Watson&rsquo;, &lsquo;You see, but you do not observe&rsquo;);
sendMessageCurried(&lsquo;Sherlock&rsquo;)(&lsquo;Watson&rsquo;, &lsquo;You see, but you do not observe&rsquo;);
sendMessageCurried(&lsquo;Sherlock&rsquo;, &lsquo;Watson&rsquo;)(&lsquo;You see, but you do not observe&rsquo;);
sendMessageCurried(&lsquo;Sherlock&rsquo;)(&lsquo;Watson&rsquo;)(&lsquo;You see, but you do not observe&rsquo;);</p>

<p>var fromSherlocktoWatson = sendMessageCurried(&lsquo;Sherlock&rsquo;, &lsquo;Watson&rsquo;);
fromSherlocktoWatson(&lsquo;You see, but you do not observe&rsquo;);
```</p>

<p>Wohohoh! We&rsquo;ve made it! And as you can see, it can be quite useful to have this syntax available. Furthermore, a major advantage is that the curried function is totally transparent as it still can behave as a normal one (<em>look at the third line on this example, we can call it in a &lsquo;normal&rsquo; way</em>).</p>

<p>And we&rsquo;re done! I hope you liked it.</p>

<blockquote><p>No. You can go further!</p></blockquote>

<p>Wait, <strong>what</strong>? Isn&rsquo;t that enough? You&rsquo;re not impressed yet?<br/>
Ok ok, it&rsquo;s only because I like you, nice reader, (and because you&rsquo;ve managed to read it so far), that we&rsquo;re going to improve this function.</p>

<h4>3 &ndash; The spiciest curry function</h4>

<p>I hope you&rsquo;re ready because this is going to be tastier than a <a href="http://en.wikipedia.org/wiki/Bhut_Jolokia">ghost pepper</a> (a pepper 900.5 times hotter than a Tabasco sauce according to wikipedia!).</p>

<p><img class="center" src="/images/currying/ghost-pepper.jpg" title="&lsquo;ghost pepper&rsquo; &lsquo;ghost pepper&rsquo;" ></p>

<p>For this last example I&rsquo;m using the <code>_</code> notation to refer to an &lsquo;empty&rsquo; or a &lsquo;placeholder&rsquo; variable.</p>

<p><code>js
var _ = {};
</code>
<em>Attention, this could enter in conflict if you&rsquo;re using a library as <a href="https://lodash.com">lo-dash</a>. So, to avoid this conflict you can easily replace the <code>_</code> variable on the following examples with the keyword <code>undefined</code>. Also, if you need one of your parameters to be equal to <code>{}</code>, this code won&rsquo;t work. So going with <code>undefined</code> is a way more bullet-proof solution. But the <code>_</code> notation is more simple to read.</em></p>

<p>``` js
function curry(fn, length, args, holes) {</p>

<pre><code>length = length || fn.length;
args   = args   || [];
holes  = holes  || [];

return function() {
    var _args       = args.slice(),
        _holes      = holes.slice();

    // Store the length of the args and holes received
    var argLength   = _args.length,
        holeLength  = _holes.length;

    var allArgumentsSpecified = false;

    // Loop vars
    var arg     = null,
        i       = 0,
        aLength = arguments.length;

    for(; i &lt; aLength; i++) {
        arg = arguments[i];

        if(arg === _ &amp;&amp; holeLength) {
            holeLength--;
            _holes.push(_holes.shift()); // first hole became the last one
        } else if (arg === _) {
            _holes.push(argLength + i); // stores the hole's position
        } else if (holeLength) { // is there a hole available?
            holeLength--;
            _args.splice(_holes.shift(), 0, arg); // insert arg into the args list at the hole's index
        } else { // just an arg with no hole to fill, add him to the args list
            _args.push(arg);
        }
    }

    allArgumentsSpecified = (_args.length &gt;= length);
    if(allArgumentsSpecified) {
        return fn.apply(this, _args);
    }

    // keep currying
    return curry.call(this, fn, length, _args, _holes);
};
</code></pre>

<p>}
```</p>

<p>This is it! The implementation is really different from our initial naive implementation. Because here we have to handle the <code>holes</code> and manage our <code>args</code> differently.
Basically, the main difference here is the <code>for</code> loop. We just keep references to our arguments <code>holes</code> and we use them to build our <code>args</code> correctly.
This is more complex but now the usages are really interesting.</p>

<p>Let&rsquo;s have a look:</p>

<p>``` js
// #1 &ndash; rgbCreator</p>

<p>var rgbCreator = curry(function(red, green, blue, alpha) {</p>

<pre><code>return 'rgba(' + red + ', ' + green + ', ' + blue + ', ' + alpha + ');';
</code></pre>

<p>});</p>

<p>// prints &ldquo;rgba(204, 160, 29, 0.9);&rdquo;
rgbCreator(204, 160, 29, .9);
rgbCreator(204)(160)(29)(.9);
rgbCreator(204, 160)(29)(.9);
rgbCreator(204, _, 29, .9)(160);</p>

<p>// prints &ldquo;rgba(204, 160, 29, 0.5);&rdquo;
var halfOpacity = rgbCreator(<em>, </em>, _, .5);
halfOpacity(204, 160, 29);</p>

<p>var shadeOfGrey = rgbCreator(0, 0, 0, _);
var opacity  = 0;
var shades   = [];
for(; opacity &lt;= 1; opacity += 0.1) {</p>

<pre><code>shades.push(shadeOfGrey(opacity));
</code></pre>

<p>}</p>

<p>console.log(shades);</p>

<p>// #2 &ndash; bind functions
var logger = function() { console.log(&lsquo;Event occured!&rsquo;); };</p>

<p>// We&rsquo;re expecting 3 arguments. It&rsquo;s due to the fact that document.addEventListener is a native function.
var bindEvent     = curry(document.addEventListener, 3)(<em>, </em>, false);
var bindClick     = bindEvent(&lsquo;click&rsquo;, <em>);
var bindMouseMove = bindEvent(&lsquo;mousemove&rsquo;, </em>);</p>

<p>bindClick(logger);
bindMouseMove(logger);</p>

<p>```</p>

<p>I kept the examples simple so that you easily understand the concept. If you run the second one in your console, you&rsquo;ll see that it&rsquo;s logging everytime you move/click with your mouse.</p>

<p>Voilà, you reached the end of this article! To go further you can even try to refactor and then add the <code>curry</code> function to the <code>Function.prototype</code> itself.<br/>
I hope you&rsquo;ve learn something new here and that you&rsquo;re going to use it on your own projects. Feel free to write any comments.</p>

<p>If you want to discover more about Javascript, you can have a look to this <a href="/categories/learn-js">serie of articles</a></p>
]]></content>
  </entry>
  
</feed>
